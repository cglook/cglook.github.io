{"pages":[{"title":"","text":"唐艺昕 李沁 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"title: 分类date: 2014-12-22 12:39:04categories: Testing #分类名type: “categories”about: /about/tags: /tags/sitemap: /sitemap.xmlcommonweal: /404/","link":"/categories/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息： 从事cg 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。","link":"/about/index.html"}],"posts":[{"title":"博客源码分享","text":"写在前面 博客源码包括两个主题icarus和next，在主题基础之上参照各网友博客，以及自己的一些想法做出的一些修改以及增加部分新元素。 以下是修改后的需要的部分配置，其余的配置参照icarus主题配置和next主题配置。因为修改了原作者源码，有什么问题请先联系我，不要去麻烦原作者了，能自己解决的问题就不要麻烦别人了，每个人的时间都很宝贵。膜拜和感谢所有模块的原作者,orz👻,辛苦了。 欢迎围观：博客+主题源码、纯主题源码、博主博客 一、icarus主题之上主要改动 新增gitalk最新评论widget 首页增加热门推荐 增加弹性配置影音（可加音乐、视频）模块 丰富弹性配置about页面 新增弹性配置友链模块 整体布局左右拉伸了一点，紧凑一些 文章页双栏模式、固定导航栏 引入可配置看板娘 归档页加入了一个文章贡献概览 置顶文章的设置 文章列表评论数显示 文章中推荐文章模块配置 增加深色主题切换 加入加密文章 碎碎念功能 透明无界样式 简化部分widget数据，加入查看全部按钮 gitalk评论增加评论开关，评论列表中标记博主 还有什么新的，好的feature欢迎大家随时提出来，有能力有时间就做出来 二、部分配置说明：本机环境：1234192:hexo-theme-icarus-removeif xx$ node -vv11.1.0192:hexo-theme-icarus-removeif xx$ npm -v6.4.1 克隆博客代码到本地1git clone https://github.com/removeif/hexo-theme-icarus-removeif.git 开始部分配置：敲黑板！！！！首先全局以及主题中的_config.yml配置成自己的对应参数。 1.热门推荐，最新评论：仅针对gitalk评论有效，如果配置完后显示本博客相关评论、推荐，请详细阅读这一条热门推荐，最新评论，文章评论数关联的js文件路径：themes/icarus/source/js/comment-issue-data.js以下引号里的地址改成自己对应的博客评论的issues的仓库相关的值。repoIssuesUrl改两个值（removeif和blog_comment改成自己对应的） themes/icarus/source/js/comment-issue-data.js12345// 评论issues仓库 by.removeif https://removeif.github.io/var repoIssuesUrl = \"https://api.github.com/repos/removeif/blog_comment/issues\"; // removeif：用户名，blog_comment：评论的issue仓库// 评论issues仓库 clientId、clientSecret怎么申请自行搜索，关于这暴露两个参数的安全问题，查看 https://removeif.github.io/2019/09/19/博客源码分享.html#1-热门推荐，最新评论：var clientId = \"46a9f3481b46ea0129d8\";var clientSecret = \"79c7c9cb847e141757d7864453bcbf89f0655b24\"; github api 详情可以参照官方api说明关于配置暴露client_id和client_secret安全性问题，gitalk作者有解释对应主题中的_config.yml要开启如下配置，xxx换成自己的，否则无效。 themes/icarus/_config.yml >folded1234567891011comment: type: gitalk owner: xxx # (required) GitHub user name repo: xxx # (required) GitHub repository name client_id: xxx # (required) OAuth application client id client_secret: xxx # (required) OAuth application client secret admin: xxx #此账户一般为用户名 GitHub user name 文章中能创建issue需要此用户登录才可以，点了创建issue后刷新一遍才能看到！！！！ create_issue_manually: true distraction_free_mode: true has_hot_recommend: true # 是否有热门推荐 has_latest_comment: true #是否有最新评论 说明： has_hot_recommend: true 是否开启首页热评，false-不开启，true-开启 has_latest_comment: true 是否开启最新评论，false-不开启，true-开启 热门推荐数据为评论数最多的文章，🔥后面的数字：根据文章的评论数*101 。 最新评论：为该仓库下，所有issue中的最新评论。 目前的最新评论有1分钟的本地缓存，评论后可能1分钟后才能看见最新评论，出于性能优化，每次请求接口处理还是挺耗时，comment-issue-data.js中可以自己去掉。 2.友链数据文件：文件路径：themes/icarus/source/js/friend.js相应格式增加自己需要的数据。 3.影音数据文件：文件路径：音乐：themes/icarus/source/json_data/music.json视频：themes/icarus/source/json_data/video.json相应格式增加自己需要的数据。 4.关于页面时间轴记录数据文件：文件路径：themes/icarus/source/json_data/record.json相应格式增加自己需要的数据。 5.看板娘配置主题中的_config.yml配置如下设置 1live2Dswitch: off #live2D开关 on为打开,off为关闭 6.置顶设置：.md文章头部数据中加入top值，top值越大越靠前，大于0显示置顶图标。修改依赖包中文件removeif/node_modules/hexo-generator-index/lib/generator.js如下： node_modules/hexo-generator-index/lib/generator.js >folded12345678910111213141516171819202122232425262728'use strict';const pagination = require('hexo-pagination');module.exports = function(locals){ var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) { if(a.top == undefined){ a.top = 0; } if(b.top == undefined){ b.top = 0; } if(a.top == b.top){ return b.date - a.date; }else{ return b.top - a.top; } }); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, { perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: { __index: true } });}; 7.配置文章中推荐文章模块根据配置的recommend值（必须大于0），值越大越靠前，相等取最新的，最多取5条。recommend（6.中top值也在下面示例）配置在.md文章头中，如下 123456789title: 博客源码分享top: 0toc: truerecommend: 1 keywords: categories-githubdate: 2019-09-19 22:10:43thumbnail: https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20190919221611.pngtags: 工具教程categories: [工具教程,主题工具] 8.文章中某个代码块折叠的方法代码块头部加入标记 &gt;folded，如下代码块中使用。 main.java >folded123456789// 使用示例，.md 文件中头行标记\"&gt;folded\"// ```java main.java &gt;folded// import main.java// private static void main(){// // test// int i = 0;// return i;// }// \\\\``` 9.加入加密文章如下需要加密的文章头部加入以下代码 1234567891011121314---title: 2019成长记01top: -1toc: truekeywords: categories-java#以下为文章加密信息encrypt: truepassword: 123456 #此处为文章密码abstract: 咦，这是一篇加密文章，好像需要输入密码才能查看呢！message: 嗨，请准确无误地输入密码查看哟！wrong_pass_message: 不好意思，密码没对哦，在检查检查呢！wrong_hash_message: 不好意思，信息无法验证！--- 注：加密文章不会出现在最新文章列表widget中，也不会出现在文章中推荐列表中，首页列表中需要设置top: -1 让它排在最后比较合理一些。 10.碎碎念的使用在github中，创建碎碎念issue，并且打上对应的label（eg:666666）对应配置中为id，填写到source/self-talking/index.md文件中如下对应位置，其余配置也要改成自己的，如clientID等。 12345678910111213&lt;script&gt; var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }) gitalk.render('comment-container1')&lt;/script&gt; 如下： 11.本博客样式（透明无界）只需要放开themes/icarus/source/css/base.styl文件中以下样式代码注释即可，默认是注释的没启用 base.styl >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//=================本博客使用样式 start// 首页去图.body_hot_comment .comment-content .card-comment-item .ava, .media-left, .is-6-widescreen .card-image { display: none;}hover-color = #deeafb;// 去card.card { background-color: unset; //box-shadow: unset;}.navbar, footer.footer { background-color: unset;}body:not(.night) .navbar:hover,body:not(.night) .footer:hover,body:not(.night) .card:hover,body:not(.night) .pagination:hover,body:not(.night) .post-navigation:hover{ background-color: hover-color; box-shadow: 0 4px 10px rgba(0,0,0,0.05),0 0 1px rgba(0,0,0,0.1);}.pagination, .post-navigation{ padding: 10px;}.pagination .pagination-link:not(.is-current), .pagination .pagination-previous, .pagination .pagination-next { background-color:rgba(255,255,255,0);}.timeline .media:last-child:after { background: unset;}.footer { box-shadow: 0px 4px 10px 10px rgba(0,0,0,0.05); padding: 3rem 1.5rem 2rem;}@media screen and (max-width: 1087px) .navbar-menu { background-color: unset; }//=================本博客使用样式 end 如下： 精简部分widget数据widget中的归档和分类和标签精简了，数据多时很丑，改为了分别展示5条和10条和20条，增加了查看全部。 gitalk评论增加评论开关，评论列表中标记博主需要关闭评论的在文章头部加入 comments: false,原来已经评论的依然会显示，如下 原来已有博客文章的迁移，只需要把原来对应的文章放到source/_posts里即可。然后去对应文章下面创建评论issue。 以上配置好后12345$ npm install #安装依赖包（只需要执行一次）ps:如果是纯主题仓库，可直接把本文最后的json文件复制到博客下面的依赖文件package.json后在执行此命令$ hexo clean #清除缓存$ hexo g #编译 $ hexo s #启动服务 $ hexo d #推到远程 安装依赖包（只需要执行一次），以后修改了代码 只需要执行后面几条就好。 ok,enjoy it!！👏👏 有什么问题，欢迎issue里讨论。 写在后面如果你有问题请反馈: issues （请务必先于issues中寻找答案）如果你喜欢该主题: star如果你想定制主题: fork 文章中横竖图demo；对于横竖图推荐分开使用，且长宽一致的，如统一手机拍照、电脑截图使用方法：md文章中放入以下代码 index.html>folded123456789101112131415161718+ 横竖图&lt;div class=\"justified-gallery\"&gt;![张芷溪](http://wx1.sinaimg.cn/large/b5d1b710ly1g6bz7n92s7j212w0nr1kx.jpg) ![李一桐](http://wx2.sinaimg.cn/mw1024/005RAHfgly1fvfc4f19qfj33402c0qv9.jpg) ![gakki](http://wx1.sinaimg.cn/mw1024/70396e5agy1g5qe457i6yj21660ogtap.jpg) ![李一桐](http://wx1.sinaimg.cn/mw1024/005RAHfgly1fuzz17s2q3j32e43cku0x.jpg) ![彭小苒](http://wx1.sinaimg.cn/mw1024/d79c9b94ly1g1pb1uthr5j21f02iox6t.jpg)&lt;/div&gt;+ 横图4&lt;div class=\"img-x\"&gt;![v4](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191022182226.png) ![v3](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191018114126.png) ![v4](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191022182226.png) ![v3](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191018114126.png)&lt;/div&gt;+ 竖图5&lt;div class=\"img-y\"&gt;![电池](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191024145940.jpg) ![打王者荣耀](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191024141906.jpg) ![支付宝付款](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191024141926.jpg) ![锤子便签](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191024145956.jpg) ![电池](https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191024145940.jpg)&lt;/div&gt; 效果如下（多图左右拉查看） 横竖图 横图4 竖图5 博客快照： 主页 深色主题 置顶 文章评论数 推荐文章模块 归档 留言 友链 美图 影音 关于 提供hexo博客目录下依赖包 package.json1234567891011121314151617181920212223242526272829303132333435363738394041{ \"name\": \"hexo-site\", \"version\": \"3.0.0\", \"private\": true, \"scripts\": { \"build\": \"hexo generate\", \"clean\": \"hexo clean\", \"deploy\": \"hexo deploy\", \"server\": \"hexo server\" }, \"hexo\": { \"version\": \"4.2.0\" }, \"dependencies\": { \"ajv\": \"^6.10.2\", \"bulma-stylus\": \"0.8.0\", \"deepmerge\": \"^4.2.2\", \"hexo\": \"^4.2.0\", \"hexo-blog-encrypt\": \"^3.0.3\", \"hexo-deployer-git\": \"^2.1.0\", \"hexo-generator-archive\": \"^1.0.0\", \"hexo-generator-category\": \"^1.0.0\", \"hexo-generator-feed\": \"^2.2.0\", \"hexo-generator-index\": \"^1.0.0\", \"hexo-generator-tag\": \"^1.0.0\", \"hexo-log\": \"^1.0.0\", \"hexo-pagination\": \"^1.0.0\", \"hexo-renderer-ejs\": \"^1.0.0\", \"hexo-renderer-inferno\": \"^0.1.1\", \"hexo-renderer-marked\": \"^2.0.0\", \"hexo-renderer-stylus\": \"^1.1.0\", \"hexo-server\": \"^1.0.0\", \"hexo-util\": \"^1.8.0\", \"inferno\": \"^7.3.3\", \"inferno-create-element\": \"^7.3.3\", \"js-yaml\": \"^3.13.1\", \"moment\": \"^2.22.2\", \"save\": \"^2.4.0\", \"semver\": \"&gt;=5.0.0\" }}","link":"/posts/1a54ada2/"},{"title":"Typora 完全使用详解","text":"Typora 完全使用详解 Typora 是什么？Typora 是一款支持实时预览的 Markdown 文本编辑器。它有 OS X、Windows、Linux 三个平台的版本，并且由于仍在测试中，是完全免费的。 在这篇文章中，我希望以「Typora 是什么」这个问题为线索，向大家全面介绍这款令人爱不释手的笔记应用。 一个 Markdown 文本编辑器Typora 首先是一个 Markdown 文本编辑器，它支持且仅支持 Markdown 语法的文本编辑。在 Typora 官网 上他们将 Typora 描述为 「A truly minimal markdown editor. 」。 官网首页 关于 MarkdownMarkdown 是用来编写结构化文档的一种纯文本格式，它使我们在双手不离开键盘的情况下，可以对文本进行一定程度的格式排版。你可以在 这篇文章 中快速入门 Markdown。 由于目前还没有一个权威机构对 Markdown 的语法进行规范，各应用厂商制作时遵循的 Markdown 语法也是不尽相同的。其中比较受到认可的是 GFM 标准，它是由著名代码托管网站 GitHub 所制定的。Typora 主要使用的也是 GFM 标准。同时，你还可以在 文件 - 偏好设置 - Markdown 语法偏好 - 严格模式 中将标准设置为「更严格地遵循 GFM 标准」。具体内容你可以在官方的 这篇文档 中查看。 严格模式 写得舒服一个文本编辑器，写得舒服是关键。我曾说过，「更有趣的是，一个笔记应用不会因为它支持 Markdown 语法而高级或易用很多。」，细枝末节处的人性化考虑才是最重要的。而 Typora 的编辑体验显然是经过深思熟虑设计的产物。 我认为：一个优秀的笔记应用应该给用户选择 Markdown 语法风格的权利。而 Typora 在这一点上是我目前见过所有 Markdown 笔记应用中做得最好的。 文本编辑设置 通过打开 文件 - 偏好设置 你会发现 Typora 为编辑体验的考虑细致到了令人叹为观止的程度。Typora 中提供了大量有关 Markdown 偏好的设置，据此，你可以构建一个几乎完全适合自己的 Markdown 编辑器。下面我将依次介绍一些与文本编辑体验有关的功能亮点。 智能标点我认为「智能标点」是比较有趣的一点。它可以自动帮你将不是很美观的直引号 &quot; ' 转化为更美观的弯引号 “ ‘ ’ ”。具体内容你可以在官方的 这篇文档 中查看。关于直弯引号在 macOS 上如何输入你也可以看 这篇文章。 图片插入Typora 的图片插入功能是广受好评的。要知道，Markdown 原生不太注重图片插入的功能，但你可以在 Typora 中： 直接使用 右键 - 复制 Ctrl + V 将网络图片、剪贴板图片复制到文档中 拖动本地图片到文档中 Typora 会自动帮你插入符合 Markdown 语法的图片语句，并给它加上标题。 复制图片 你也完全可以使用图床来保证文档在分享后图片仍能正常显示。 更强大的是，Typora 支持在拖动或 Ctrl + V 网络图片后自动将其保存到本地。你可以在 文件 - 偏好设置 - 编辑器 - 图片插入 中选择复制到哪个路径，什么情况下需要复制。 图片插入 这一功能保证了即使网络图片源失效了，你还有本地的备份可用。同时也能使你的文档文件夹更合理、完整。 打字机模式和专注模式「打字机模式」使得你所编辑的那一行永远处于屏幕正中。 「专注模式」使你正在编辑的那一行保留颜色，而其他行的字体呈灰色。 你可以在 视图 - 专注模式 / 打字机模式 中勾选使用这两个模式。 两种模式 实时预览我想很果断地下这个结论：到现在还不支持编辑界面实时预览的 Markdown 编辑器基本可以退出市场了。Typora 在这一方面显然已经领先了一大步——他们连 Markdown 语法的标记都在实时预览中消去了。当你离开正在编辑的有格式的文本段后，Typora 会自动隐藏 Markdown 标记，只留下「所见即所得」的美妙。他们把这称为 Hybrid View。 所见即所得 为了防止一些程序 bug 的发生（虽然在我使用下来感到是很少的）导致格式问题无法修改，Typora 保留了一个「源代码模式」。你可以通过 视图 - 源代码模式 或左下角的 &lt;/&gt; 按钮进入。 源代码模式 大纲 / 文件侧边栏 侧边栏 Typora 会根据你 Markdown 标记的 H1、H2、H3…… 各级标题为你呈现一个大纲。 你也可以选择查看文件夹中的文件，但由于目前 Typora 只支持查看 md 文件，因此我认为文件侧边栏这个功能还是很鸡肋的。 空格与换行Typora 在空格与换行部分主要是使用 CommonMark 作为标注规范。与前文提到的 GFM 一样，CommonMark 也是比较流行的 Markdown 语言规范（解析器）之一。 空格：在输入连续的空格后，Typora 会在编辑器视图里为你保留这些空格，但当你打印或导出时，这些空格会被省略成一个。你可以在源代码模式下，为每个空格前加一个 \\ 转义符，或者直接使用 HTML 风格的 &amp;nbps; 来保持连续的空格。 软换行：需要说明的是，在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。在 Typora 中，你可以通过 Shift + Enter 完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。 硬换行：你可以通过 空格 + 空格 + Shift + Enter 完成一次硬换行，而这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。 换段：你可以通过 Enter 完成一次换段。Typora 会自动帮你完成两次 Shift + Enter 的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。 Windows 风格（CR+LF）与 Unix 风格（CR）的换行符：CR 表示回车 \\r ，即回到一行的开头，而 LF 表示换行 \\n ，即另起一行。所以 Windows 风格的换行符本质是「回车 + 换行」，而 Unix 风格的换行符是「换行」。这也是为什么 Unix / Mac 系统下的文件，如果在 Windows 系统直接打开会全部在同一行内。 你可以在 文件 - 偏好设置 - 编辑器 - 默认换行符 中对此进行切换。 下附以上各空格、换行、换段的测试结果图。具体内容你可以在官网的 这篇文档 中查阅。 空格、换行、换段 emoji 表情如今 emoji 表情越来越多地出现在一些网站文章中，但在桌面端（特别是 Windows 系统）文本编辑器上插入 emoji 是一件十分麻烦的事情。在使用 Typora 之前，我打出 emoji 表情的办法基本有两个： 输入法联想：优点是比较方便，但会插入一张图片而不是一个字符，在许多情景下都不是很合适。 复制 emoji 符号：优点是能保证符号的形式，但显然每次用都需要去复制，比较麻烦。 输入法联想 在 Typora 中，你可以用 :emoji: 的形式来打出 emoji，软件会自动给出图形的提示，还是比较好用的。 Typora 中输入 emoji 一个学术文档编辑器除了基本的文本编辑体验极佳之外，Typora 还是一个非常优秀的学术文档编辑器。当然作为一个轻量级的、基于 Markdown 的编辑器，它不能与那些 LaTeX 编辑器相提并论，但它仍支持了许多可用于学术写作的功能。 LaTeX LaTeX 是一种基于 TeX 的排版系统，由于它易于快速生成复杂表格和数学公式，非常适用于生成高印刷质量的科技和数学类文档。如果你常阅读数学、计算机等领域的学术论文，你一定对 LaTeX 不陌生。 Typora 原生支持 LaTeX 语法，你有两种方式输入 LaTeX 风格的数学公式： 行内公式（inline）：用 $...$ 括起公式，公式会出现在行内。 块间公式（display）：用 $$...$$ 括起公式（注意 $$ 后需要换行），公式会默认显示在行中间。 具体的 LaTeX 语法在此不赘述了，你可以在 这篇文章 中查看。 代码高亮Typora 中代码的插入也可以分为行内和块间两种： 行内代码：用 `...` 或 ``...`` 括起代码，代码会以主题中设置的样式出现在行内，但不会实现代码高亮。 代码块：输入 ``` 后并输入语言名，换行，开始写代码，Typora 就会自动帮你实现代码高亮。Typora 原生支持许多编程语言代码块的语法高亮，基本日常常用的编程语言它都能很好地支持。除此以外，你也可以直接换行开始写，而后再选择语言。 代码块 表格在 Markdown 中插入表格一直是一件比较头疼的事情。在一般的 Markdown 编辑器中，你可以通过以下的格式插入表格： | 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 | 乍一看还挺直观好用的是吧？但想想，一旦表格内容层次不齐，又或是表格长得难以下手，直接用键盘输入表格就显得十分麻烦和痛苦了。 好在 Typora 为我们提供了图形界面的插入表格的功能，你只需要在行内 鼠标右键 - 插入 - 表格 ，并输入行数和列数，Typora 就会自动生成一张样式不错的空表格。 Typora 表格 链接引用与脚注链接引用类似于我们常在论文末尾看到的「参考文献」的写法，你可以通过 []: 的语法来为你的文档加上链接引用。 脚注在少数派的文章中也很常见，即某段话结尾右上角标有数字标记，页面底部进行注释的写法。你可以在需要插入脚注标号的位置写 [^ number ] ，再在下方通过 [^ number ]: 在文档中插入脚注。注意不要遗漏了脚注编号 number 前后的空格。 链接引用和脚注 文件系统除了前文提到的文件侧边栏，Typora 还提供了一些耦合度不高的文件系统。 快速打开：你可以通过 文件 - 快速打开... 或 Ctrl + P 快捷键快速打开最近的文档。 保存：Typora 支持自动保存，一般很少有写好的文档丢失的情况。同时它也提供了诸如「保存」、「另存为」、「保存全部打开的文件…」之类的功能。 导入：Typora 支持非常多的文件格式：.docx, .latex, .tex, .ltx, .rst, .rest, .org, .wiki, .dokuwiki, .textile, .opml, .epub。 导出：Typora 原生支持导出 PDF，HTML等格式。你可以根据软件内提示安装 Pandoc 插件来导出更多例如 docx，LaTeX 等格式。 导出 一个伪装成文本编辑器的浏览器当我的一个朋友问我「Typora 有什么好写的？」时，我回答「Typora 是一个伪装成文本编辑器的浏览器」。是的，事实上如果你有一定的计算机基础，你可以找到许多有关于「Typora 其实是一个浏览器」的蛛丝马迹。 图片插入 在图片插入的选项中，Typora 用了「复制图片到 ./${filename}.assets 文件夹」的说法，而这其实是网页前端常用的 Javascript 字符串模板语法的风格。 再比如，Typora 将更遵循 GFM 标准的 Markdown 语法模式称为「严格模式 Strict Mode」，这一说法常见于 HTML 和 JavaScript 编程中。类似「源代码模式」的说法也是同理。 当然，最明显的一点是当你按下 Shift + F12 快捷键时，页面会弹出一个基于 Chrome 的开发者工具栏，也就是我们在浏览器中常说的「审查元素」。 审查元素 伪装从何而来？当我们把视角放在「Typora 是一个支持 Markdown 语言的文本编辑器」的出发点来考虑这个问题，一切就都显得很明白了。 John Gruber 在 2004 年用 Perl 创造了 Markdown 语言，这个语言的目的是希望大家使用「易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的 XHTML（或是 HTML）」。也就是说，在 Markdown 诞生之初，它就是为了被浏览器阅读而设计的。 我们在用 Markdown 语言撰写文稿的时候，其实本质上是在借助某种编程语言的转化（解析器）来编写一个 HTML 网页。Markdown 从它诞生之初就与 Web 技术有着及其紧密的联系。 如果我说，我们每一篇文稿都是一个网页，那就很好理解了。Typora 利用解析器先将我们写的 Markdown 文档解析成为 HTML 文档，再为它嵌入一个 CSS 样式，最后再加上可能需要的脚本等。 HTMLHTML 是一种标记语言，主要负责构成网页的骨架，它包含所有不加装饰的网页元素。在 Typora 的使用场景下则是所有的文本、段落、标题等的记号。 你可以把一张网页想象成一幅数字油画，HTML 就是那个黑白线条的底，上面写满了数字标记，示意你哪一块区域要涂什么颜色。而 CSS 则负责在对应的区域涂上颜色，甚至加上一些装饰等。 数字油画 HTML 标签Typora 支持许多常用的 HTML 标签，如果你了解 HTML 语法的话，你可以写出十分美观丰富的文档页面。 HTML 标签 事实上你可以在 Typora 中完成许多基本的 HTML 风格的文本输入，例如 HTML 字符、HTML 块、HTML 风格的注释，甚至是视频和音频。具体支持的功能和限制请在 官方文档 中查阅。 有了这一功能，我们就可以在 Typora 中创造出远超普通 Markdown 文档的页面效果。 导出为 HTMLTypora 原生支持将文档导出为 HTML 格式的文件，并选择是否要嵌入 style（也就是后文我将提到的 CSS 的部分）。 除此之外，由于其本身「浏览器」的属性，你可以直接在实时预览界面用 Ctrl +C 复制到 HTML 代码。一个实用的用处是将这些 HTML 代码直接 Ctrl + V 黏贴到微信公众号后台，基本可以保证两边显示效果相同。这一点不仅使公众号推送可以有更自由、美观的样式，也让编辑、排版更轻松了。（由于微信自带浏览器的一些特性，可能有少部分 CSS style 不能生效，建议多多校对。） CSS为了让文档更美观，我们可以为其加上 CSS style。我认为 Typora 对 CSS 的支持让它成为一众桌面笔记应用中最与众不同的一个。在 Typora 中 CSS 被称为「主题」，但其本质仍是 CSS 文件。你可以在 文件 - 偏好设置 - 主题 - 打开主题文件夹 看到这些 CSS 文件。 主题 主题文件夹 选择不同的主题可以使文档拥有不同的外观，但不会影响内容。Typora 自带了若干主题，你也可以在 官网 下载更多的主题。 主题商店 除此以外，如果你有一定的 Web 编程基础，你当然也可以自己修改、新建适合你使用需求的 CSS 文件。我自己就写了一份名为 WeChat 的 CSS 文件，来符合我公众号特定的排版需求，例如正文是 15px，页边距是 8，小标题是 18px 等等。 参考 Front-matter - Hexo 让 Markdown 写作更简单，免费极简编辑器：Typora 使用 Typora 一次性搞定公众号写作与排版 简中求效：Markdown 遇上 LaTeX 关于Typora + pandoc导出文件功能的介绍 我的 LaTeX 入门 选择正确的 Markdown Parser Typora —— 能用 ⌘C⌘V 插图的 Markdown 编辑器 HTML Support in Typora - Typora Markdown - Wikipedia Windows、Unix、Mac不同操作系统的换行问题-剖析回车符\\r和换行符\\n 简中求效：Markdown 遇上 LaTeX 通用标注 (CommonMark) Whitespace and Line Breaks - Typora","link":"/posts/9954ada2/"},{"title":"PureRef参考图软件","text":"PureRef是一个简单而轻量级，查看参考图像的工具。PureRef 下载地址 添加图像你可以从计算机中拖放文件，也可以直接从图片浏览器拖放图像，还可以使用右键单击菜单或ctrl+v粘贴图像。 编辑图像你可以通过几种方式编辑你的图片，以满足你的参考需求： 缩放/相机选择一个或多个图片：1、单选：单击左键。2、多选：左键框选。3、加选：按Shift不放+左键单击图片。选择全部：Ctrl+A居中放大一个或多个图片：双击左键/空格，重复操作返回。调节软件界面大小：拉扯软件四个角落，可以随意调整软件界面大小。缩放：鼠标中键平滑缩放图片：Ctrl+Alt+左键软件界面调整到选择的图片大小：Ctrl+Shift+R复位摄像机： Ctrl+G整体平滑变焦 Z+左键选择图片平滑变焦：Shift+V+左键 移动移动图片：左键拖拽图片移动软件界面：软件框内右键拖拽软件，可以把它移到屏幕上合适的位置。软件界面内平移：按住鼠标滚轮，并移动鼠标。 旋转/翻转旋转图片：Ctrl+左键旋转图片，加上shift按45°旋转。翻转图片：Shift+Alt+鼠标左键（上下滑动=上下翻转，左右亦然）复位变换：Ctrl+Shift+T 排列按图片缩放大小排列：Ctrl+P有序的排列：Ctrl+Shift+p按加法排列：Ctrl+Alt+A按名字排列：Ctrl+Alt+N堆叠图片：Ctrl+Alt+S（把所有图片堆叠一起） 顶端显示总是显示在底部：Ctrl+Shift+B总是显示在顶部：Ctrl+Shift+A最大化： Ctrl+F（重复操作返回）最小化： Ctrl+M单独显示选择图片： Ctrl+Y（重复操作恢复）显示色码：S+左键显示图像坐标： D+左键 编辑裁剪图片：你只想显示图片其中的一部分。1、按住C键不放+左键框选图片想显示的区域，就自动裁剪了。2、取消剪裁：选中图片，Ctrl+Shift+C撤销/返回：Ctrl+Z添加注释： Ctrl+N 画布/锁窗优化画布： Ctrl+O打包并优化画布： Ctrl+Shift+P（重新排列并优化画布）锁帆布： Ctrl+R（锁住图片，不能对图片进行编辑，重复操作返回）锁窗： Ctrl+W（锁住软件窗口，不能移动，重复操作返回）调整到选择的大小： Ctrl+Shift+R 常规打开图片所在目录 ：Ctrl+Shift+O（选择图片在操作）加载图像： Ctrl+I保存：Ctrl+S保存为：Ctrl+Shift+S输出场景： Ctrl+E（输出画布）输出选择图像 ：Ctrl+Alt+I关闭软件：Ctrl+X复制：Ctrl+C粘贴：Ctrl+C删除：Delete 透明度/颜色所有图片灰度转换： Ctrl+Alt+G（重复操作恢复）选择图片灰度转换： ALT+G减低软件不透明度： Ctrl±增加软件不透明度： Ctrl++黑暗背景：ALT+1灰色背景：ALT+3白色背景：ALT+2选择图像变化不透明度： Ctrl+Alt+Shift+左键（重复操作恢复）","link":"/posts/40/"},{"title":"收集常用的网站(持续更新...)","text":"引言： 对一些常用网站的收集(主要是为了方便自己换电脑时懒得去导出浏览器收藏夹)，会持续更新… 常用网站 软件安装管家（能找到满足日常办公的很多软件） 搜索引擎： 学术搜索 Pytorch： 一个不错的pytorch学习网站 访问速度更快的网址 在线工具 在线JSON校验格式工具 正则表达式在线测试 RGB颜色查询对照表 在线正则表达式测试 UrlEncode编码解码 时间戳在线转换 草料二维码生成器 在线Java编辑器 MarkDown转HTML 在线图标下载 Greasy Fork 油猴脚本 科技小c 高清壁纸wall 在线图片尺寸大小修改 Unicode转中文 拷贝兔 ppt模版下载 CSDN自助下载 第三方视频 免费影视网站 电影天堂 人人视频 80s 4K屋 七七 视频鱼 动漫 音乐 50音 BT磁力 磁力导航 网盘搜索 DogeDoge搜索 云盘精灵 盘天才 python pythonlibs &amp;&amp; 清华大学镜像源 &amp;&amp; python第三方包 pyppeteer 爬虫 ElasticSearch api &amp;&amp; ElasticSearch - api1 &amp;&amp; ElasticSearch - api2 持续更新…","link":"/posts/de8d88af/"},{"title":"Normalmap法线贴图","text":"观念的建立 什么是法线贴图**(Normal Map)** 法线贴图常常用在低解析度模型，伪装出高解析度的模型细节表现。法线贴图的每个像素储存了法线，法线就是一种向量，纪录了高解析度模型的表面斜度。红色、绿色、蓝色通道分别控制了每个像素的方向。 当你把法线贴图到用到低解析度模型，法线贴图上面的像素会控制了低阶析度模型的向量，造成了模型表面更多细节的假象。然而，从侧面来看，模型本身并没有改变。 贴了normal map的低模 没有贴normal map的低模 高模 切线空间（**Tangent-Space）vs** 物件空间（**Object-Space**） 有两种法线贴图，一种是切线空间，另外一种是物件空间。物件空间也被称做是区域空间，或是模型空间。世界空间基本上跟物件空间是一样的，只是世界空间需要模型维持他原始的转向，不改变旋转或是变形，因此世界空间这类型的法线贴图很少使用。 切线空间的法线贴图（**Tangent-space normal map**） 如上图, 主要会是蓝色的，物件可以移动，或是变形。很适合用在变形物件。例如角色、动物、旗子…等等。 · 贴图可以很容易被重复使用，例如不同形状的模型。 · 贴图也可以很容易做重复贴图tiled，镜像也很容易。虽然有些游戏引擎对镜像normal不是很支援。 · 很容易用叠合的方式绘制细节。 · 很容易进行影像压缩。 · 但是比较难避免来自低模vertex normals 的smoothing的问题。 物件空间的法线贴图（**Object-space normal map**） 如上图, 颜色是彩色的，物件能被旋转，但是不能有变形，除非修改shader让它支援可变形的法线贴图。 · 很容易产生高品质的曲率，因为它完全忽略了低解析度模型粗糙的smoothing。 · 效能上比切线空间的贴图要好，但是没有差非常多。 · 很难重复利用，不同的模型需要不同的贴图。 · 很难做tile，镜像也需要特殊的shader支援。 · 很难以图层叠加的方式来添加细节，绘制的细节必须要先转换成物件空间，才能正确地与物件空间的法线贴图叠合。 · 图片压缩效果不好，因为蓝色通道很难像切线空间的贴图一样，在shader里面重现，而且三个色彩通到包含了非常不同的资料，很难做压缩。如果压缩的话会产生很多的杂点，建议使用一半解析度的物件空间贴图解决这个问题。 不同类型的法线贴图之间的转换 法线贴图可以由切线空间转换成物件空间，反之亦然。 Diogo “fozi” Teixeira先生写了一个工具叫做— NSpace。它可以把物件空间的法线贴图转换成切线空间，在3ds max可以完美地运作。它利用3ds Max的硬体shader，相同的切线基础来做转换。为了要看到结果，透过Normal Bump map载入翻转的贴图，勾选”Show Hardware Map in Viewport”。Osman “osman” Tsjardiwal先生它写了NSpace的使用者介面，你可以到这里下载，只需要把这个跟NSpace exe放在同一个资料夹即可。Diogo先生还想替这个工具添加更多功能。 Joe “EarthQuake” Wilson先生说，8Monkey Labs 有个工具让你载入参考模型与物件空间贴图，然后载入切线空间的法线贴图，调整tile的数值，我们必须要载入模型才能知道切线法线的方向是否有误。大部分的状况是可运作的，但是常常会扭曲法线，因此你必须要把模型切成某种smoothing groups，然后才执行这个程式。然后我们才会合成这个混合的材质，套用在我Photoshop的原始图上面。 RGB**通道** Shaders可以利用不同的技术来渲染切线空间法线贴图，但是法线贴图的方向通常是在游戏里面组成的，通常红色通道储存了X轴(通常是向左或是向右)，绿色通储存Y轴(向上或是向下)，蓝色通道储存Z轴(方向是自表面往外)。 切线空间法线贴图的红、绿、蓝通道 如果你发现光源角度错误，可能是因为法线贴图所指的方向，红色或是蓝色，指到了相反的方向。为了要修正错误，你可以改shader或是很简单地把相对应的颜色通道翻转，因此黑色的pixel变成白的，或是白的变成黑的。 有些shader 预期颜色通道会换，或是重整。为了要支援特殊的压缩格式，例如DXT5_nm通常会认为X轴在akpha通道Y在绿色通道，红色与蓝色是空的。 切线基础（**Tangent Basis**） 切线空间的法线贴图是一种特别的顶点资料，称为切线基础tangent basis。这跟UV座标很类似，差别在于切线基础提供了模型表面的方向性。它组成了相对于表面的座标系统，这个座标系统是以每个pixel的法线为基础储存在法线贴图里面。 光线Light rays是位于世界空间，但是法线储存在法线贴图里，用的是切线空间。当有贴normal-map的模型被渲染出来，光线必须要从世界空间切换成切线空间，这个转换要透过切线基础tangent basis。而射入的光线会跟法线贴图里面的法现做比较，这会决定每个pixel的模型要怎样被光线照明。有时候，有些shader不转换光线，但是转换法线贴图里面的法线。由切线座标转换成世界座标，然后世界座标的法线会跟光线做比较，来决定模型是否被照明。要用怎样的方法取决于你怎样写shader，但可得到相同的结果 不幸的是，对美术来说，有很多方法能计算切线基础（tangent basis）。3ds Max、Maya、DirectX 9、NVMeshMender、 Eric Lengyel等等方法。这表示用不同方法做出来的法线贴图，可能没办法在其它的应用程式里面正确地被渲染。美术必须要做点测试，才能知道怎样的参数最好，当算图引擎或是游戏引擎，渲染你的模型时，shader必须要跟你的法线贴图产生器采用相同的切线基础。否则，你会得到不正确的照明，尤其是在跨过UV的缝隙的地方。 xNormal SDK支援自订义的切线基础，当程式设计师使用xNormal SDK，把它导入到算图引擎自己的切线基础，美术使用Xnormal去做bake 法线贴图，就能够与算图引擎完全地配合了。 在低解析度模型上面的UVs与vertex normals会直接影响到切线空间的法线贴图的颜色，每个切线基础的vertex都是由三个属性结合的：mesh vertex的法线，受到smoothing影响、vertex的切线，通常是根据V轴贴图座标而来、还有vertex的双向切线，根据程式码而来，通常称为双向法线binormal。这三个向量会对每个vertex产生一个轴，产生一个特定的切线空间的转向，这些轴会被用在当被光线照射到的时候，由世界空间到切线空间产生适当转换。因此，你贴法线贴图的模型才能表现出正确的光照。 当三角的vertex法线是垂直往外的，那张法线贴图的pixel颜色会呈现中性蓝(128,128,255)，这表示pixel的法线会直接由低阶析度的模型表面垂直地指向外面。当pixel 法线是往左或是右偏移，它的颜色可能会比较红，或是比较不红，但是这要取决于法线贴图是怎样储存x轴的资料的，是定义成正的，还是负的。同理，当法线是往上或是往下偏，颜色会呈现的比较绿或是比较不绿，如果vertex normal不是完全跟三角面垂直的话，法线贴图的pixel一定会被染上颜色，而不是单纯的中性蓝。vertex normals与法线贴图里面的pixel normals最后会结合起来，构成最终的per-pixel surface normals。 Shaders的功能是利用法线贴图里面XY轴资讯来控制方向大部分的应用程式定义红色向右是+X，绿色向上+Y。但是3DSMAX是定义+X、-Y。这就是为什么常常会需要翻转绿色通道，才能得到正确的最后结果， 因为shader会定义特定的方向。 当模型上的共用边，是在UV空间上有不同的角度，在边缝的地方就会以不同颜色呈现，切线基础会利用这个颜色来对模型做照明。 当你查看角色的切线空间的法线贴图，通常会在UV边缝的地方看到不一致的颜色。这是因为UV shell通常会在mesh上面有不同的朝向，这是由3D模型转成2D贴图的必要之恶。角色身体的部分可能是垂直的shell，而手臂可能是水平的。因此在法线贴图上面的法线必须要扭转这两个不同朝向的UV shell，切线基础能够重新转向(扭转)光源。当光线射入到模型表面的区域空间时，当光照照应这个边缝时，看起来会很平顺。 当美术对模型的切线空间法线贴图进行tile时，例如地形，结果通常是正确的，因为模型具有统一的切线空间方向。如果模型具有连续的UV座标，或者法线贴图有很大的方向渐层，那切线空间就不会是统一的，因此地形表面可能会出线边缝。 低模（**Low-Poly**）的建模 游戏模型必须要很小心的最佳化，产生美丽的剪影，刻划出比较好的edge-loops。这样对变形的时候比较好，最小化极端的vertex normal改变。这样才能具有更好的shading。 为了要产生最佳化的游戏模型，例如好的剪影、好的loops产生好的变行动化。你可以添加第二级的subD细分，然后进行数位雕塑；或是直接用low-poly模型开始改，接着把edge loops塌陷掉，或是切出新的边、添加细节、或者你可以重新进行拓普。 UV**座标** 法线贴图烘培工具只会捕捉到在0-1 UV范围的法线，因此超出范围的会被忽略。 面向前的UV只有一份会在baking时后计算，如果你的mesh使用重叠的UV，会产生错误，因此在烘培之前，最好移除重叠的UV。 对称的UV (红色部分), 在烘培前偏移一个单位 如果你移除重叠的UV，然后镜像，最后产生的结果会一样。当然也可以不要镜像，对大部分的游戏引擎都没差，但是小心ZBrush使用UV偏移来管理模型的可视度，但是其实这也没太大差别。因为ZBrush cage mesh通常是跟游戏里面要做烘培的材质是不同的。 必须要避免在烘培法线贴图后改变UVs，因为旋转或是镜像UV，会造成法线贴图无法跟切线基础对应上去，这会产生光照的问题。 在3ds max里面，W是第三个材质座标。会被用在3D程序性材质，并且会储存UV通道里面的vertex color (你需要RGB的3轴，因此UVW可以储存vertex color) 。烘培问题可以把移动重叠的UV，沿着W轴移动到-1。这跟把重叠的部分在U或是V移动一个单位意思是一样的。Render To Texture这套工具总是会对W轴上面最高的UV进行烘培，然后利用W烘培可能会产生问题，因为这个东西通常是隐藏的，除非你可以地查看它，这对团队工作并不好。而且这个数值不会在输出的时候储存，高的W数值也可能会让UVs不好选取或是焊接。 镜像（**Mirroring**） 法线贴图能够用镜像的方式处理，产生对称的细节，这样可以节省UV空间。这样可以让你在法线贴图里面放置更多的细节，因为模型上的texture pixels变得更细致了！ 如果是采用物件空间的贴图，镜像的法线贴图需要特殊的shader支援。如果切线贴图。镜像通常会产生shading缝隙，但是这个缝隙可以被减小或者隐藏，取决于你用的方法。 标准的镜像工作流程 \\1. 把模型一半删除 \\2. 整理剩下的模型的UVs，让它充满整个UV空间。 \\3. 从镜像模型产生完整的模型，在边缝的区域把vertex焊接起来。 \\4. 移动镜像的UV整整一个单位。 \\5. 烘培法线贴图 烘培法线贴图 有时候，美术会想要在烘培之前删除模型对称的那一半。 这样做是错的，因为常常沿着切面开口的vertex normals会朝向开口处而另外一面也没有模型可以平均化这个法线这样会在法线贴图上产生明显的光线缝隙 最好的做法是用完全对称的模型来进行法线贴图的烘培，不要只用一半的模型。 避免对称的UV产生重叠或是烘培错误，把对称的UV移动到0-1 UV空间之外。因此只有一个非对称的UV在0-1范围内。 为了要避免texel在UV shell之间泄漏出来，请确认每个shell有足够的留边，包含延着法线贴图的边，每个UV shell都不应该在0-1UV范围内碰到彼此，除非你想要在贴图上呈现tile的效果。 这里再举另外一个例子,模型的一半先拆好UV然后用Symmetry做对称. (原文取自这里 ) 这时候选取模型的左半部, 把左半部的UV 移到0-1的UV空间之外, 因为我们不希望因为对称的UV相叠而重复计算法线贴图 当我们用高模来产生法线贴图时, 左侧的法线贴图的结果是正确的 法线贴图是利用RGB值来让低模产生变形的效果. 在模型的右侧, 计算出来的法线贴图一定是正确的因为法线贴图就是根据高模的右侧来产生的. 但是对于模型的左侧计算出来的反线是相反方线, 因为左侧的模型是以symmetry产生的; 因此, 当法线会让模型往外凸时左侧的模型照里来说应该会往内凹(相反方向), 可是因为左侧的UV其实跟左侧模型正好是相反的, 因此负负的正, 最后的结果让两侧的模型贴上法线贴图效果是正确的 . 游戏里面的效果是正确的. 中央对称**(镜像)** 如果镜像的缝是在连续的模型表面上，例如人脸的中央，这可能就会产生光照缝 Epic Games的Unreal Engine 3 (UE3) 它们的对称模型通常就是采用中央对称。Epic的做法是利用另外一个法线贴图做为细节贴图DetailMap。这可以把镜像的缝隙，diffuse/specular的光照分散开来。而光照模型的话，Epic有一种技术可以几乎把镜像缝完全消除。 左图的detail normal map细节法线贴图能够把右图的缝隙, 巧妙地隐藏起来 偏移对称（**Offset Mirroring**） 偏移对称是一种方法，这样让你的缝隙不会出现在正中央，例如角色的头。UV缝可以放在耳朵。从那个地方产生UV缝。 这可以避免罗夏效应（Rorschach）。因此可以产生非对称的细节，但还是可以节省空间，因为头的两侧还是可以对称，但是对称面不会同时被看到。 镜像偏移不会把边缝移除，但是可以把缝隙移到比较不明显的位置。 平色镜像（**Flat Color Mirroring**） 这里教你怎样用手绘的方式把镜像的切线空间法线。用手绘的方式涂上平色的法线，用的是中性蓝，但是这只能用在垂直或是水平的UV缝，不能用在任意角度的UV缝，这样可以移除沿着镜像的缝隙。 元件对称（**Element Mirroring**） 对称的缝可以完全地避掉，如果你在对称中心不放置模型的话。例如，如果你把一个detached的模型放在中心的位置，这个模型就可以独立地设定贴图，而两侧的模型还是可以进行对称，不论对称的模型是否共用vertex normals。有了非对称的元件，就不会出现任何的缝了。 望远镜中间的元件，以红色显示。是一个独立的非对称UV，让整个模型对称但是完全不会有缝隙。 Smoothi**ng Groups** 与硬边 每个模型上面的每个vertex都至少有一个vertex normal。vertex normal会用在控制三角面的方向，控制光照个结果。如果法线是朝向光线，那三角面就会被完全地照明；如果背对光线，那三角面就不会被照明。 但是每个Vertex，能够有超过一个vertex normal。当共用边的两个三角面有不同的vertex normals时，会产生shading缝隙，称之为模型的硬边（hard edge）。3ds Max的Smoothing Groups能够产生硬边与软边，Maya则是利用Harden Edge与Soften Edge来控制。这些工具都能产生硬边与软边，经由分裂或是合并vertex normals。 硬边会在vertices产生多个法线 当模型完全地使用软法线(单一个smoothing group)，光线会对差异极大的vertex normals进行内插。如果你的算图引擎跟烘培器（baker）不使用相同的切线基础的话，会产生shading错误，所以要尽量避免极端的vertex normals差异，才能避免这个问题。 硬边对于模型本来就有的缝是最好的。例如，你可以沿着车胎的框添加硬边，避免轮胎模型扭曲车体。机械性的模型通常会使用硬边。 对大部分的模型，最好是在UV缝的地方添加硬边，这个没有绝对的解决方法，你必须要尝试出最适合你游戏的方法。 当你使用物件空间的法线贴图时，vertex normal的问题就会消失，你不再依靠模型上面的原始vertex normals。物件空间的法线贴图会完全忽略vertex normals，物件空间的贴图让你使用所有的软边，在低解析度模型也不会有bevel，也不会出线光照错误。 低模有设定smooth group与全部设为硬边,产生不同的法线贴图. (图文取自这里 ,作者Ariel Chai) 使用**Bevels** Bevels/chamfers能够改善模型的剪影而且能产生更好的反射高光。 但是bevel常常会产生很长的三角面，会降低游戏里面的算图效能。即时的算图器往往对于狭长的三角面会有问题，因为这会产生很多算图的sub-pixel的区域。 Bevels也会让vertex count数值大增这能会让位移的时候耗费很多效能与记忆体硬边也会增加vertex count 但是对于共用UV空间的边缝不会增加vertex count 请看以下文章 跟bevel相比，使用硬边，而且让UV shells能够稳合，通常能够产生较高的效能与美丽的结果 如果没有做bevel, 但是有设定smooth group, 用不同的显示模式: 3ds max的硬体显示, xNormal与raytrace算图的比较. 很显然3dsmax的normal map即时显示效果不好! 若是对低模做了bevel, 就算是用3ds max的硬体显示, 也能够有好的效果 ] 低模没有设定smooth group, 在即时显示的时候, 右边的那个box出现怪异黑色线条. 请看下图说明原因 主要是因为你的UV都拆在同一块, 相接的地方因为法线方向不一致, 所以才会出现怪异的黑边. 解决之道是把UV拆开成独立区块, 如此就不会出现怪异黑边. 举另外一个例子,由kodde先生所提供(原文请点这里 ): 这里比较对低模有加bevel, 或是设定smooth group产生normal map贴回低模后, 效果比较. 由左至右为: 高模, bevel的低模, 全部硬边的低模, 全部软边的低模. 很显然有做bevel的低模 [ 全部硬边2. 全部软边3. 有做bevel, 3的效果较佳, 缺点是耗费比较多的poly数量. 如果还是不清楚为什么会这样,以下CryEngine Mod有很好的图示: 如图所示, 橘色为低模, 蓝色为高模. 当计算法线贴图时, 由低模发射出的射线跟高模有交错点(红点) 但是这样产生的normal map效果不好看 这里跟上图类似但是把高模往外推. 没有设定smooth group与bevel以前, 低模的射线会有死角(deadzone) 因此计算出来的法线贴图原角的边缘非常不明显 如果把低模设定全部为一组smooth group, 射线在圆滑处与高模有比较好的交错点(红色小点) 这样产生的normal map效果很不错, 但是有一个缺点是从很极端的角度来看边界会有奇怪的亮光. 最后, 加了bevel同时也设定smooth group. 射线与高模有很好的交错点 ] 得到了很棒的normal map, 在极端的角度观看有不会有怪异的亮光. 编辑**Vertex Normals** 如果你使用bevels的话，藉由编辑vertex normals， 让大面积的平面具有垂直的法线，shading结果会改善。vertex normals通常会强迫跨过小的bevel面，而不是跨过大面积，请看以下教学： 有bevel的模型会让法线偏向 建立高模**(High-Poly)** SubD建模与数位雕刻，是大部分用来产生法线贴图的相关技术。 有些美术比较喜欢先建出游戏模型(低模)，有些喜欢先建高模，有些则是介于两者之间。顺序其实是由个人自己取决。三种都可以产生很棒的结果。 · 先建立出游戏模型，然后提高解析度，然后再雕刻。 · 建立高解析度的模型，然后据此建立出游戏模型。 · 建立基本模，然后提高解析度来雕刻它， 同时降低解析度再修改到变成游戏模型。 如果游戏模型是从细分表面雕刻而来，建议可以把某些edge loops，切割添加或是移除，来达到模型最佳化。 斜面的**Extrusions** 在高模进行Extrusions，它的斜面最好做的明显一点，这样才能产生较好的法线贴图。 mental ray Round Corners Bump mental ray算图引擎会自动地产生bevel的算图效果，称之为Round Corners Bump。这也可以bake到法线贴图里面，在3ds Max、Maya与XSI都能利用此功能。 Jeff Patton贴了一篇有关于如何把Round Corners Bump功能撷取出来，让你可以套用在其他材质上。 Michael “cryrid” Taylor 写了一篇在XSI里面利用Round Corners的功能。 XSI可以把这个效果成功地烘培到法线贴图上面，但是3ds Max似乎会不正确地烘培。Maya则是完全不能烘培，可能是要把.mi shader改成正确的座标系统max就会变正常了。 上图左右都是同样一个模型,左边那个有套用Mental ray round corner的shader,会在算图时产生bevel的效果. (原文取自这里 ) 烘培**(Baking)** 根据高模进行的法线转换到低模，称之为烘培。这个烘培的工具通常根据某段距离自低模投射出来，发射出射线到高模，当这条射线跟高模交错，它会纪录模型的表面法线，储存在法线贴图里面。 为了要理解这些选项会怎样影响你的法线贴图，先用简单的box来做测试，然后很快速地实验UV mirroring、smoothing groups等等。这会让你了解设置参数。 反锯齿（**Anti-Alias****ing**） 开启超级采样或是反锯齿(或是multi-ray casting)，能够帮助你修掉当高解析度模型跟自身重叠，重叠在低模的UV边界以内，产生的锯齿边。不幸的是，启动反锯齿会算的比较慢，也比较耗记忆体。 没有开启反锯齿就去烘培材质会在高模模型重叠的区域产生锯齿错误 一个小技巧，就是算图的时后计算原图的两倍大，然后在Photoshop里面缩小。这个缩小的动作会进行pixel重新采样，在缩放以后，确认贴图有re-normalize。因为如果没有这样做会产生很多小的杂点，Re-normalizing可以利用NVIDIA的法线贴图滤镜来做。 3ds Max的超级采样处理edge padding效果不好，会在留白的pixel间产生黑色的长条，如果会出现这样的问题话，先关掉padding选项，然后之后再做padding。重新baking，不要勾选超级采样，或是利用Photoshop滤镜来处理。 烘培透明度（**Baking Transparency**） 有时候你需要从物件烘培法线贴图，这个法线贴图要用在透明度控制，例如带有透明度控制的树叶。很不幸地，烘培的软体会完全忽略你高模的透明度。 正确的光照设定产生完美的透明度 为了要解决这个问题，对模型的上视图进行渲染，这只对当你对低模使用平面的UV投影，计算切线空间法线贴图有用。 请确认上视图长宽能与低模的planar UV投影尺寸相符，这对等角摄影机的精确放置会有帮助，高模则需要套运特别的照明或是特殊的材质。 (1)以下教学有提到照明设置 直接在3D应用程式里面建立法线贴图 用3D软体产生高品质的法线贴图 绘图技术顾问Xbox游戏内容与设计团队 (2)material shader也可以做到相同效果但是不需要打灯 NormalTexMap 这是一个用3ds Max脚本产生的贴图 InfoTexture贴图外挂 由上往下的光照环境设定 边界留白（**Edge Padding**） 如果法线贴图的边界没有留边，会在UV边界的地方产生缝隙。 粉红色是模型的材质区域黑色是背景区域.当游戏在进行时,为了要让材质显示更平顺会套用filter到材质上面称为down sample降采样.如果背景区域的颜色跟材质本身的颜色差异太大将采样产生的mip可能会吃到黑色背景区域. (原文连结请点这里 ) 因此在画材质或是产生法线贴图时要设定padding (留边) 避免上述状况 高模材质 如果高模套用了mental ray Arch &amp; Design material材质，那么3ds max就无法正确地产生法线贴图，如果法线贴图的结果是全黑，那就改用Standard材质吧。例如这帖有讨论到的： Reset Transforms 在烘培之前，请确认你的低模的位移形变已经重置了。这点很重要，通常建模的过程中，会进行旋转与缩放，但是这些会产生大量的区域座标空间local “space” 。而这样会很容易产生法线贴图的算图错误。 解决交错的模型 投影的过程通常会产生遗失、重叠、交错 而高模的自身交错让要产生干净的法线贴图变得十分困难，通常会出现在手指附近，把ray distance设定的太高会导致拾取到其它的手指，太小的话在低模与高模距离较远的地方会出现问题。 还好有几种方法可以解决这类的问题 \\1. 改变cage的形状，手动边即投影cage的点，能够帮助你产生更好的cage，能够更紧密地包覆住手指。 \\2. 用材质来限定投影或是UVs \\3. 把模型炸开，请看这帖讨论栏 \\4. 用不同大小的cage来进行烘培，然后在Photoshop结合起来 当烘培时随机产生的像素错误 如果你采用3ds Max的『Render To Texture』的功能，来进行烘培的话，你可能会发生随机的杂点，这只会当你使用原本的模型来做投影，而这个模型用了不同的UV通道的时候。 在烘培法线贴图时产生的随机像素错误 有两种方法解决 · 在复制的模型上添加push的修改器，把数值修改为0.01 · 在算图设定的地方关闭滤镜，避免反锯齿你也可以在Global Supersampler关闭反锯齿。 波浪状的法线贴图 当你为圆筒状模型进行法线向量计算时，低解析度与高解析度之间会产称波纹状的法线贴图，有很多方法可以避掉这个问题。 \\1. 很简单只需要修改cage的形状，这样改变rays的朝向，在最下面的法线贴图教学里。Ben “poopinmymouth” Mathis展示如何在3ds max里面达到上述动作， 相同的方法如下图： \\2. 细分低解析度模型，让它尽量稳合高解析度模型。Jeff “airbrush” Ross在这个教学影片有解说如何在Maya里面做这个效果。 \\3. 把波浪线涂抹掉，由Ben “poopinmymouth”写的法线贴图教学，Mathis介绍了一个教学如何把波浪的法线贴图用涂抹的方式涂掉。 \\4. 使用独立的平面投影方法用来捕捉筒状区域的细节，因此ray-casting会更平均例如要添加轮胎的胎纹，胎纹可以由一条平的模型产生，然后在2D绘图软体里面以图层方式叠合上去。 \\5. 调整cage的形状，让扭曲的法线贴图消失 调整cage的形状就可以产生没有波浪纹的法线贴图了 左图为低模,右图为高模(本例得原文请点这里 ) 这是在max里面预设的低模投射到高模时cage的模样, 很丑 产生的法线贴图有明显的波浪纹 左图贴上法线贴图的低模与右图相比有明显的波纹 这是因为在计算法线贴图时的射线扭曲的问题(红色) 有一个很简单的方法可以解决那就是Reset cage. 但是会出现上图的错误, 法线贴图被剪切掉了. 因为cage没有把高模包起来 Reset cage后把cage 原柱的上下两个盖子往内推最后就可以得到正确的法线贴图 三角化 在烘培以前，最好要把低模先三角化，由polygons转换到纯的三角面，这样避免之后的vertex normals 改变，产生奇怪的高光。 当四边面在Modo里面转成三角面时，内部的边常常会翻转，造成shading结果的不一致。 有时候烘培工具或是模型的输出/输入会把多边形重新三角化， 一个四边面的多边形，其实是两个三角面，内部的边(对角线)是可以改变方向的，当四边面的点被移除时，软体对多边形模型的演算法会试着维持四边面表面合理的非重叠形状，这是藉由翻转内部的边(对角线)达成的。 高光会受到三角面的影响，翻转对角线可以修正错误，请看这篇说明文 处理**Cages**的问题 Cage对法线贴图处理有两项意义：一是对低模而言是用来细分模型表面所用，二是用来计算法线贴图的ray-casting模型。以下是谈到ray-casting cage.的主题。 大部分的烘培工具提供您distance-based raycast工具，ray (射线)会沿着每个vertex normal朝外，在设定的距离里，设定射线投影回来的距离，当射线与高模交错时他会对那瞬间的法线采样。 硬边与有距离范围的射线(distance-based raycast) (灰色的区域)，会造成射线(黄色)遗失，还有射线重叠(蓝色)。 灰色区域则是完全使用软边soft edges，能够避免分岔的法线产生ray-casting的错误。 很不幸地，用了distance-based raycast的方法，分岔的vertex normals会造成烘培的高模部分移失或是边缝的问题。 有些软体让你使用cage的模型，这基本上就是把低模膨大，这样就会自每个vertex往回raycasts。这样会自cage产生膨大的模型。 绘制**(Painting)** 不要害怕在Photoshop里面编辑法线贴图，毕竟法线贴图本身也是一张贴图，因此你可以复制、模糊化、混合等等操作。只要最终效果是好看的就好了，对于法线贴图处理颜色的了解会帮助你有有效率地绘制法线贴图。 利用高解析度模型来产生的法线贴图通常会比用材质做出来的好，因为你是真的自精确，高模来截取适当的法线，这表示法线贴图的像素基本上就是重现了高模的表面细节，因此可以获得非常逼真的效果。 如果你是利用一张贴图来产生的法线贴图，结果可能看起来很平，或是得到完全不能用的法线贴图。如果你没有调整到适当的数值范围的话，大部分的法线贴图产生软体会假定输入的图是heightmap，其中黑色是最低点，白色是最高点。如果你想要把手绘材质选换成法线贴图，结果会非常不好看，最好的办法是从高模产生一张具有大，中细节的法线贴图，然后再利用相片产生的法线贴图来处理模型最细微的表现，例如纤维、刮痕等等。 有时候，预算无法负担由高解析度模型产生法线贴图，例如角色或是主要环境资产还是要以高模产生法线贴图，但是对于比较不重要的环境原件，从heightmap产生的法线贴图就很够用了，也不需要花太多时间来处理。 平色**(Flat Color)** 平色(128,128,255)会产生一个完全垂直于模型表面的法线，只要vertex normals也是垂直的话。请记住，法线贴图的每个像素的法线会从vertex normals，产生每个像素的法线偏移，如果你希望法线贴图的某个区域是平的，那就产生没有偏移的vertex normals，采用128,128,255的颜色就可以。 这当你在镜像法线贴图时，并采用反射渐层时特别明显，反射通常会把法线的角度强化出来，因此法线的错误就会更明显。 镜像的法线贴图，当你使用(127,127,255)的颜色会产生缝隙，要用平色128的效果比较好。 在逻辑上，127似乎才是真正介于0-255的中间数值，但是实际上在用的时候，128才比较实用，当你用(127,127,255)或是用(128,128,255)来绘制时，很明显的127会产生法线的弯曲，而128才能产生完全平的颜色。 这是因为大部分的游戏流程使用unsigned normal maps，更多细节请看这里。 把两张法线贴图叠在一起 把两张法线贴图叠在一起，可以很快速地添加模型细节，例如皱纹、裂痕等等。细节能够用height map绘制，然后用转换软体产生法线贴图，这样的细节法线贴图可以与用高模产生的法线贴图叠合在一起。 以下是四种混合的方式，请注意预设值是采用CrazyBump (强度50 33 33)，但是软体本身使可以让你调整任意强度的，在混合之后又重新标准化贴图（re-normalized）一次。 上图用了四种混合模式 \\1. 由Ryan Clark撰写的CrazyBump软体，是采用3D空间来计算法线贴图的混合，而不是用2D，这是保留细节最好的方法，而且每个图层强度可以个别修改。 \\2. 在Photoshop里面进行法线贴图的混合，正值是Linear Dodge；而负值采用Difference mode，结合了Photoshop Action来加速合成动做，这是免费的，但是跟CrazyBump相比比较不精确。 \\3. 由Paul “paultosca” Tosca制作的Making of Varga，把法线贴图混合在一起，对红色与绿色通道以Overlay模式混合，绿色与蓝色通道用Multiply混合，这产生的混合效果会比单纯用Overlay的效果要更强烈。Leo “chronic” Covarrubias在这里有一步一步的详细教学： \\4. 由Ben “poopinmymouth” Mathis做的Normalmap Deepening 说明利用Overlay模式产生的法线贴图混合，CGTextures的教学里面说明了Scott Warren如何利用多图层来产生法线贴图。 由Nvidia-filter normalizing产生的灰阶图可以产生很好的height map。Polycount 论坛上面有提到不同的混合选项，请看2D工具的章节： 预先做好的图库 你可以建立一堆做好的形状，之后可以取用，这样可以节省法线贴图的制作时间例如螺丝、管线等等装饰物，这些形状会以bipmap储存，带有透明度，因此可以用图层的方式与法线贴图做混合。 重新标准化法线**(Re-normalizing)** 重新标准化法线表示重设每条法线的长度到1的范围内 法线贴图shader利用三个颜色通道产生每个pixel的法线长度与方向，这些法线会影响模型在场景里面的光照，但是如果你用手绘，或是混合多个法线贴图的化会改变法线的长度。大部分的shader只会认法线长度是1，但是有些shader会动态地去进行重新标准化法线，例如3ds Max的硬体shader。 如果你的法线贴图没有标准化(normalized) 而且显示的shader也没有重新计算法线的功能，那你可能在模型显示的时候看到许多错误，高光会产生很多杂点表面会出现许多怪异的阴影，为了要解决问题。你可以使用NVIDIA的法线贴图滤镜，提供了很简单的重新标准化法线re-normalize的功能，只要勾选Normalize Only就好了。Xnormal也有提供相同的Photoshop滤镜。 NVIDIA的法线标准化的选项 有些shaders会压缩法线贴图，通常会把蓝色通道完全地舍弃，因此是即时的重新计算，但是shader必须要重新标准化法线，才能建立资料，因此客制化的法线长度会完全地被忽略掉。 把AO(Ambient Occlusion)算到Normal Map里面 虽然shader可能不会对法线贴图进行标准化，但是AO 却真的可以烘培到法线贴图里面，这会让模型表面的缝隙的法线长度缩短，造成该区域接受到较少的光源，这可以用在diffuse与高光或是其他任何使用法线贴图的通道，例如反射通道。 为了要把AO烘培到法线贴图里面，首先调整AO图层，让黑色区域低到恰好与128的灰色相同，然后把AO图层设定为Darken mode，这会让法线贴图的法线变短。让该区域的表面获得更少的光线，产生更暗的光照。 这个技巧不能用在具有标准化法线功能的shader，例如3ds Max的硬体shader 。必须要修改shader才能让它真的吃到你客制化的法线。大部分的shader都假定法线长度是1，因为这样的程式码比较好写， 而且这个技巧不能用在大部分的法线贴图的压缩格式，因为这类压缩都会舍弃蓝色通道，然后重新计算shader 这是一个标准化法线的必要动作。 想要有最好的结果，通常把AO跟color map做multiply，而不要把AO混到法线贴图里面。 逆光**(Back Lighting)**的状况 你可以客制化法线贴图，产生有趣的效果，如果你蓝色通道翻转，法线就会朝反方向去，因此会模拟出逆光效果。 模拟出树叶的次表面散射效果 这是树叶的贴图，第二个diffuse很简单地把颜色反转，偏移了hue，180° 调整饱和度。 树叶用了shader，然后用了两种不同的diffuse shader贴图：一个使用正常的切线空间法线贴图，另外一个用相同的图，但是反转了蓝色通道，这会造成背面的叶子只会被背面的光线所照明。树叶的模型是双面的，但是两面使用相同的shader 因此这效果可以用在任一角度的光线，还有另外一个优点，因为树木开启自身阴影计算，树叶的影记不会接受的直接照明，因此背面不会显是翻转的法线贴图，因此就可以造假出当光线直接打到树叶时才会有的透光效果(SSS)，这对整个森林不能用，因为自身阴影与双面法线贴图太耗效能了，但是可以用在重点物件或是用在有做LOD的树木，在远方会切换到效能比较好的shader。 Shaders**与缝隙** 必须要使用正确的shader才能避免在UV断点的地方看到缝隙，shader必须要跟烘培前的状况使用相同的切线基础（tangent basis）。如果不是的话，光照结果不是对于跨UV边界的地方不一致，就是平滑面出现错误。 当你在Xnormal里面，就可以正确地显示产生的精确法线，SDK也可以让你自行撰写自己的切线空间产生器。 3ds Max Shaders 3ds Max 2011里面的Render To Texture功能，与老的切线空间切图，能够用scanline正确地渲染出来，但是如果用3ds Max shaders不能在萤幕上即时正确地显示。Max算图与即时显示用的是不同的切线基础，这个问题在你使用非有机的硬边模型的法线贴图尤其明显，smoothing的错误会显示在萤幕上，但是算图的时候不会出现。 当你使用Render To Texture产生的错误可以藉由Christoph ‘CrazyButcher’ Kubisch 与Per ‘perna’ Abrahamsen所写免费的”3Point Shader”来解决，这样shader就会跟烘培的工具使用相同的切线基础，所以可以产生几乎没有错误的法线贴图，用在旧的法线贴图上也可以。 你可以在Max萤幕上看到在maya里面烘培的切线法线贴图，效果还算ok。在萤幕显视硬体贴图，在标准材质中载入，启动Show Hardware Map in Viewport。另外一个方法是使用Render To Texture来烘培物件空间的法线贴图，使用Nspace把他转换成切线空间贴图，载入DirectX material与采用RTTNormalMap.fx shader。 绝对不要相信**3ds max萤幕上显示的normal map**效果 (原文请点这里 ) 由上往下分别是: 在maya里面产生法线贴图然后在max里面显示; 在Maya里面产生法线贴图然后在maya里面显示; 如果是在max里面产生法线贴图(利用scanline) 然后在max里面显示看到那恐怖的三角面了吗? Max里面用scanline计算出来的法线贴图 Max里面用Mental ray计算出来的法线贴图(请忽略反锯齿的问题, 为节省时间没有启用反锯齿) Maya计算出来的法线贴图 Autodesk知道这个问题，并且计划在下一版修正这个问题。 比较Maya与Max与客制化的code产生的法线贴图与即时材质显示的问题 Christoph “CrazyButcher” Kubisch 与Per “perna” Abrahamsen写了一个特别的shader/修改器，来修正这个错误，请看这个讨论串： 3 Point Studios这个法线贴图显示工具可以修正3ds max的问题 3ds max 2010不同的显示方式的比较 3ds Max**编辑法线的技巧** 在烘培之后，如果你在你的贴了法线贴图的低模上面加了edit normal的修改器似乎会让vertex normals比较松产生比较精确的萤幕显示效果 你也可以把修改器塌陷掉如果你想要的话 Maya Shaders Maya能在萤幕上面正确地产生法线贴图有正确的切线基础跟3ds Max相比也比较不会有smoothing的问题 由Brice Vandemoortele与Cedric Caillaud所写的BRDF shader 这包含了物件空间的法线贴图浮雕贴图自身阴影且确认Maya plugin manager使用有cgFX shaders 然后你就可以依此产生Lambert, Phong等等关闭高品质算图才能在萤幕上正确地显示 如果你想要使用软体算图引擎使用mental ray 但是不要使用Maya的软体算图因为mental ray能正确地解读切线空间的法线而Maya算图器会把法线贴图视为灰阶的bump map 产生难看的结果Mental ray支援Maya的hong shader 虽然它不认得插在”cosine power里面的gloss map 拉杆还是可以用地如果你不介意gloss有统一的数值Spec maps也还能运作在萤幕上使用相同的设定最好把贴图储存成TGA 格式 法线贴图的压缩 法线贴图会吃掉很多记忆体，压缩可以压到原本的1/4大小，因此你可以增加解析度或是放更多的贴图。 通常的压缩法是把蓝色通道丢掉，因为这个可以用最小的资源在shader编码里面重新计算，bitmap只会储存两个颜色通道，而非四个(红色绿色蓝色与alpha)。 这篇关于即时法线贴图压缩格式DXT Compression，从id software与NVIDIA是篇很棒的文章： DXT5nm**压缩** DXT5nm的压缩格是跟DXT5是一样的，除了把红色通道移到alpha通道。绿色通道不变，红色与蓝色通道填充相同的实体色。这样的安排称为swizzling。 绿色与alpha通道被采用的原因是DXT的压缩格式在红色与蓝色通道会用到比较高的bit深度，红色与蓝色会用相同的实体色填充，因为DXT会采用压缩系统比较不同颜色通道，如果你试着要储存红色或是蓝色材质、高光、高度贴图，这样的压缩会产生更多的压缩错误，因为他会比较所有的三个通道。 NVIDIA DXT压缩选项能够帮助降地压缩错，如果你想要添加材质到红色或是蓝色通道如果你不把红色或蓝色通道放空，产生的错误会更多。但是可能优点大于缺点，可以看看在NVIDIA研发论坛上面的讨论。 DXT1的压缩 DXT1有时候会用在切线空间的法线贴图上面，因为他是DXT5大小的一半，缺点是他会产生很多压缩的缺陷，所以后来很多人就没有用这个压缩格式。 3Dc**压缩** 3Dc压缩又称为DirectX 10的BC5压缩，它跟DXT5nm很类似，因为他只储存X, Y通道。差别是他会储存跟DXT5 Alpha channel相同的通道，跟DXT5nm的绿色通道相比会稍微高一点的bit深度，跟其他演算法相比3Dc能够产生最好的结果。不需要处理时间或是特殊的硬体。 A8L8**的压缩** DDS 格式A8L8并没有真正的压缩，只需要两个8bit灰阶通道，每个256灰阶这会让你避免使用三个颜色通道。但是shader必须要重新计算蓝色通道才能正常的运作，但是A8L8并没有节省到任何材质记忆体，它只是在送给显卡的时候转成四个通道的32bit材质。这个格式的唯一优点是减少硬碟使用空间。 标题: Maya &gt; NormalMap &gt; UDK 工作流程 翻译: Hammer Chen crapageddon: 有没有人可以解释我哪边做错了？ 我想要把我在maya高模，用低模贴法线贴图，放在udk里面。几乎要完成了，但是在udk里面模型看起来一团糟。我自认为我步骤都做对了，有没有人可以指出我哪边做错了，这边我很快速地做出骷颅头，当作练习的范例。 以下是我的步骤 \\1. 建立高模 ] \\2. 建立低模 利用高模产生产生低模，并确认模型没有突出。 3 .UV分布图 把UV分布图弄整齐，不重叠。 4 -建立法线贴图 我是用Transfer Map来产生法线贴图。 5 - 产生法线贴图与套用法线贴图 没办法完全呈现高模，但是堪用。 \\6. 多的UV组 我读了这篇它说UDK需要另外一组UV，所以我就另外做了。 \\7. 透过Actor X输出模型 我用Actor X输出低模，勾选”Obey Hard Edges。这样对吗？ 8 - 把模型输入到UDK 用以下设定 9 - 输入diffuse map 由Maya 透过Transfer map转成TGA 10 -导入法线贴图 我是用以下设定，正确否？ 11 - 建立材质 Diffuse用在diffuse与specular通道，而法线贴图就放在normal通道。 12 - 把材质套用到模型上面 以下就是套用完材质后的模型 13 - Light map 座标资讯 我发现我之前的uv没有显示，我乱调了一下参数，但是还是没有改善。 有没有人知道怎样修正这个错误 我哪边做错了？ 有更好的办法吗？ danimal回答: 请进行以下步骤，不要说他妈的我模型爆烂这样的借口： \\1. 不需要多个UV set因为你原本的UV没有叠在一起。 \\2. 如前面所提，不要像用在有机模型上面把UV切割成很多块，你每UV多一块就会在模型上面产生硬边，因此模型到最后就会产生一堆边缝，超丑的。 \\3. 不要用Transfer Maps的功能。下载xNormal来用，这是免费的，产生的品质绝对会比Maya要好，而且速度快一百倍。 \\4. Maya的功能，xNormals也一样，会产生翻转的绿色通道。你必须要到photoshop里面把绿色通道翻转，因为我个人强烈建议使用xNormal，有一个选项打开后让你可以在UDK里面正确显是绿色轴向，这样你就不需要在photoshop里面翻转了。 \\5. 你还必须要要设定低模的smoothing groups。我建议你就直接对这个低模骷颅头，设定一个smoothing group，全选Normals，Soften。 \\6. 请注意如果你把整个低模设定成Soften。UV岛的边界会自动产生分裂的点，因此，就会有缝隙。但是目标是要把缝隐藏，我建议沿着骷颅头背面切割，拆UV。 \\7. 在第六步骤，你可以得到更好的法线贴图。选取UV边界的地方，把它硬边化。因为在引擎里面这些边会是硬边，换句话说，在产生法线贴图的时候，是用完全smooth的低模来产生，但是接着选取UV shell的边界边，把它硬化，比较两个步骤产生的法线贴图，看看哪一个效果比较优。 \\8. 在导入UDK里面的时候，导入ASE。对bSingleSmoothGroupSingleTangent这个参数开启或是关闭，比较一下效果差异。 \\9. 没确，你的第七步骤设定是对的。应该没问题。 \\10. 你输入法线贴图的设定是OK，但是我建议你在做测试的时候，勾选NormalMapUncompressed 。这样法线贴图就不会压缩，你就可以看到最佳状态好比较差异，另外也别忘了设定LOD group。 \\11. 当设定材质，不要用Texture那一个模组，建议用Texture里面有一个专门给法线贴图取用的模组。（译者注：找不到这个模组, 应该是旧功能） \\12. 最后，就像之前所提到的，我会对低模再添加更多细节。如果模型很远的话没关系，但是很近的话添加细节是必要的。 基本上你需要很多试误的过程，我以前也遇到很多问题。整理以下重点：UV是最重要的，因为UV shell会影响你的硬边，还有缝隙的问题。要注意smoothing groups的设置，这也会影响到在引擎里面是如何设置的，你的法线贴图如何被渲染出来，你会得到完全不同的结果，如果你的低模的smoothing groups设定的不一样的话。 —翻译完毕— —以下为另一篇翻译—- 原文请点[这个连结](http://wiki.polycount.com/3DTutorials/Modeling High-Low Poly Models for Next Gen Games?action=show&amp;redirect=3D_Tutorials/Modeling_High-Low_Poly_Models_for_Next_Gen_Games) 标题**:** 次世代游戏高模与低模的建模技巧 翻译**: Hammer Chen** 作者: João ‘Masakari’ Costa 身为制作次世代游戏的美术，或是做游戏的mod，建模越来越复杂了。每天都会出现新的技术，而旧的技术也还没摸熟。今天，我要来谈谈建模，建立次世代游戏的资产(UE3、CryEngine 2等)。我会强调法线贴图的产生，但是这个教学并不是专注在如何在你的3D软体里面产生法线贴图，毕竟这有很多软体要提，这篇教学主要是从建模的角度切入，根据模型的细节产生法线贴图，哪些方法可行，哪些不可行，我会利用Daedalus HK模型当做范例。 \\1. 前置作业：评估。 有一件是你要知道，就是不是所有的细节都要建高模，尤其是在UV图的解析度很低的时候。有很多小细节，例如螺帽、凹陷、面板、刮痕、小洞等等的，都会由高模转低模产生法线贴图的动作，失去了细节。你必须要事先想到哪些是小细节，哪些是必须要实际建模出来的。还有请记住你的高模不是要用在电影等级或是只要算图好看就好，最重要的是最终在游戏里面的效果，因此针对游戏你可以把某些细节夸大或是减低，这样能够更容易产生好的法线贴图，这个阶段要快速想过，你可以使用不同的技术，最终的结果才是最重要的。 \\2. 前置作业：取得法线贴图与修改 就像2D美术需要很多参考图库一般，今日的3D建模师也需要建立很多的模型库：细节、3D材质、笔刷，才能加速工作流程。经常学习新的script工具，很重要；经常地学习新技巧，改善现有的技术，学习并累积经验，加强技术等级与速度。在根据高模产生法线贴图后，不要害怕修改或是添加细节，有扎实的传统美术基础很重要。毕竟，你可能会成为顶尖的建模师，如果你Photoshop技巧很烂的话，就不能自己会制材质了！ 必要工具/参考 \\3. 前置作业：聪明地工作(work smart) 这应该大家都知道，但是很多人没有这样做。不要懒得管理生产流程，最佳化你3D软体的选单、快捷键。这样你就可以加速你工作的速度与效率，把你最常用的工具摆在最显眼的位置。对的工具用在对的地方，要做有机模型的细节的时候不要害怕切换到Zbrush/Mudbox，在photosho里面增加凹陷、刮痕、小螺丝、小洞；利用deepUV来放松最终的UV。如果你的模型还没有设定动画，请确认模型可以用在动画制作上，要不然调动作的会很不爽！当你在处理UV贴图的时候，要考量到模型里面哪边会被常常看到， 哪边比较不常看到，具此调整UV大小。请不要懒惰不做这件事。最后，如同Jon Jones所说：『失败是好事』。不要害怕心的事物，尝试用新的方法来达到最佳化的结果。 用图层管理可以节省资源, 有效率地工作 \\4. 实做阶段：高模 请记住，你不是在做什么美术旷世巨作。高模的唯一目的是要让低模能够具有高品质的细节，不用担心高模的模型拓普不够完美，不必担心高模一定要一整块的模型。有些组件可以是独立的一块，尽量把模型外推，减小/夸张化细节，这些目的都是要产生高细节的法线贴图，不必担心高模内部乱七八糟，最重要的是外部的shell。因为外面才会影响到法线贴图的计算！ Smooth 的边对法线贴图的产生十分重要，为了要减小低模的硬边，这样才能产生美丽的高光效果。不必担心小的错误或是杂点，这些可以很快地在photoshop里面修掉。 除了把边界smooth掉以外，你还必须考虑到其他问题，做法A把面外往推出边界的地方有做一点chamfer，但是最终的结果会失去高度感。 做法B，有比较好看，但是在游戏里面还是不够好看。做法C 正确的做法，推出的面还有做bevel的动作，这样在高度上还渐层变化，而平滑的边让整个法线贴图的转换更平顺，即使bevel做得很小。请记住，一定要用bevel，不要只用extrude。 为什么呢？原因如下：在方法A里面，你可以看到红色圆圈的区域，交错的位置具有相同的法线向量，因此产生的法线贴图无法提供足够的细节。方法C，交错的地方能够成功地表现模型细节，因此一定要做bevel与smooth edge。对于圆形的表面也一样。例如D图： 由左至右，由上至下。第一张图是初学者的做法，法线贴图可能还可以，但是效果不会好，高模具有11K的三角面。第二张图，几何体有做平滑，拿来产生法线贴图当然很棒，但是效能会有问题。因为单单一片模型就耗了178K的三角面。右图你可以看到呈现的样子，在第二排的图片，你看到只有232个三角面的低模套用法线贴图后就可以呈现出许多细节！ 最后要分享的3DS MAX小技巧：学着用turbosmooth来做模型，它会成为你产生高模的最好工具，你只要先准备好低模，添加chamfer、ring edge loop，然后加上turbosmooth。这样你可以自行决定细致度，调高或是调低。 \\5. 实做：低模 就像Epic Game的Pete Hayes在06年的GDC所说：『低模才是王道』。重申一下这个六字真言，把这句话牢牢记在心中。就像我之前所说，高模的唯一目的就是提供低模(游戏资产)高品质细节。有些美术喜欢先做高模，然后才做低模；有些人则是相反。不论如何， 有一件事一定要做对，那就是你要让你个高模能够去与低模吻合，而不是让低模去与高模吻合。请记住，游戏资产有面数的限制，尽量让你的低模干净，有正确的几何表现，正确的edge loop，把UV边界藏起来。这样你就可以自由地修改、最佳化模型。不要害怕去修改低模或是修改它的UV。要具有弹性，视情况来评估需求，这对你来说是无价的职业技能！ 有一点我必须要强调就是—-smooth group。你在产生法线贴图前能够正确地设置smooth group是很重要的！成败就在此。另外一个圣经是：Ben Cloward说过的『smoothing group』是法线贴图的敌人。为什么，因为smoothing group会强化硬边，请看以下图表说明： 图E，显示产生法线贴图时，发生了什么事情？如果低模有好几的不同的smooth group，硬边会在两个group之间产生，因此，ray投射的时候就会有一条缝隙。在图F，你可以看到正确的设置，全部模型就只有一个smooth group，这样就不会有硬边产生。所以，请记住，把模型全部设为同一个smooth group！ 如上图，低模与高模能够完美地对应，有些凹陷处被包覆起来。这些都是必须要独立建模的部分，而不是一整块模型。我通常会把这些模型分开处理，这里总共有16片模型。 这张是我Daedalus HK模型的WIP 大约有5800多边形，贴了diffuse、高光、法线、AO、发光图，这样呈现出20 million面的高模效果！ \\6. 在Photoshop里面作后制 在个别处理独立贴图后，你可能会想用Photoshop来进行合成。就像我之前所说的，建立笔刷库、刮痕、生锈、旧化等等效果、添加皮肤细节等。再者，你可以使用照片当作参考，叠上去，利用图库产生法线贴图，但是这超出了这篇主题了这边我就不谈了。 \\7. 结论 感谢您的阅读，希望对你有帮助。我不是专家，如果你有其他方法的话就用你的方法，最终完成的品质才是最重要的。如果你是业余玩家，希望你能从这篇里面学到一些技巧，如果你是教授或是学生，希望这能让你更进步，到最后如果你想成为大师。请记住你要跟许多美术，其它已在业界的人竞争，如果你每天只花几个小时，你不太可能马上就赶上这些人。你必须专注在专业上、努力工作、 阅读教学、还有逛论坛，能够提供意见。这样你可以精进技术，做出好的作品。最后，要能对自己的作品做出批评，每次的失败不要失去动力，你会饱受批评，但是每一次都会因此进步。持续地尝试吧！你会成功地！ —-翻译完毕—- **** 标题**:针对light-maps来拆UV** 翻译**: Hammer Chen** 沿着材质的X轴做镜像 这会影响light-map材质与vertex light-maps Light-maps会用三种不同方像储存光线，然后根据实际的每个像素法线来做混合。这三个方向是固定在切线空间。因此，在世界空间会跟材质座标一样被镜射，而这个方向只在材质的X轴会对称。为了确保镜射边缝的两边都采用相同方向的世界空间，UV贴图与模型的对称边缝会尽可能地垂直。 在镜像边缝的两旁使用相同的世界座标方向是很重要的，因为这样light-map才能精确地计算出来。如果两侧用了不同的方向，光照贴图在两侧的边缝计算就会不正确，最后会导至明显的缝隙。 切线空间会建立在第一组UV set，因此，这是材质的座标，所以要沿着X轴对称。 把light-map UVs切开来做对称。 模型的light-map UVs必须在镜射的缝隙之间要留几个texel，这样做是必要的，因为这两半没办法混合在一起。如果这两半没有间距开来，那么套用到light-maps上面的smoothing filter，或是材质的bilinear texture filtering会让缝隙产生！ 请看这个墙的模型，藉由把法线贴图沿着x轴对称可以节省材质空间。 第二个UVW座标是用在lightmap上面，如上图。 为了避免在游戏中对称的那面产生边缝，要先选去镜像的那一面。 然后把那个部分切开来。 有边缝 这样在游戏里面就不会看到边缝了！ 要在哪边留边**(padding)**呢？ 有了Lightmass，在lightmap UV周围留边已经没有必要了。Lightmass会自动产生一个单位的贴图像素留边，避免产生出血的错误，因此在uv layout周围留边已没有必要而且会浪费记忆体。 在UV charts之间的边还是必要的。要留多少是根据最后套用在哪个模型上面，该模型的解析度，大约必须要间隔4个贴图像素，才能避免错误，因此如果lightmap解析度为32 两个UV charts的间距必须为整个UV空间的12.5%。然而，如果你的间距过大，就会浪费更多记忆体。 注意事项 这里会提到避免当使用静态光照产生的缝隙问题，但是这个方法无法解决lightmap高光的部分，要避免lightmap高光产生的缝隙的唯一方法是采用动态计算光线(Movable, Toggleable 或Dominant这三种类型的光源)，请查看DominantLights单元这里有更详细说明)。 当你想要移除这个缝隙的时候，请记住材质解析度是1024-2048间，而lightmap可能会有大约128x128像素，所以要rebuild lightmap。把解析度设定到你想要的。 在低解析度的lightmap还是会产生很小的缝隙。 Lightmap的UV座标可能会产生视觉上的错误，但是，适当的lightmap UV可以有效地减小缝隙的错误。建议你产生3/4的镜射，而不要恰好一半。因此，如果是对角色的脸的话，就刚好一边脸有整个鼻子，另一半没有。 基本上，除非你使用Vertex light maps才能完全地避免缝隙的产生！ 移除对称的**normal map**产生的缝 问题： 先假设各位已经有低模与高模，并且成功地产生法线贴图了！ 如果你跟材质一样用相同的对称UV，那你会产生如下很丑的缝： 要怎样修正？ 我会一步一步说明要怎样修。 这个方法也可以套用在角色身上，车子或是其他有机的模型。 1)在Photoshop里面开启法线贴图 看起来很正常 2)到贴图通道里面，因为我的边缝是垂直的所以我选取红色通道。 3)选取有边缝的区域 4)使用魔术棒，把大面积的亮部与暗部扣掉。这些是重要的模型细节区域。 5)如果你的模型很细，或是会有特写，那必须要更小心的选取。 6)选取灰色：128,128,128 7)套用一个由灰色到透明的渐层色，套用到以下区域，请注意在边缝的地方刚好是128,128,128的灰色。 8)做好了以后，似乎没有太大改变 9)但是贴回到3D软体，边缝神奇地消失了！ 最后的比较效果 要注意的是，另外一个模型是去改绿色通道，而且渐层是用垂直渐层。 Bevel的区域会比较麻烦，你可能红色与绿色通道都要处理，而且要花很久的时间休，我不建议这样做除非那个部位真的很重要。 这篇教学也没有讲到怎样去修在镜射的模型产生上下翻转的光源。 如果没时间一一把所有内容看完的话**,** 这里列出几点结论**:** · UV拆的好很重要这会决定normal map的品质 · 低模要拆UV; 高模不必拆UV, 高模提供的是normal的细节而已 · 对称的模型操作流程很重要: a.先对一半的模型拆好UV b.使用symmetry产生对称的模型c.把镜射那一半的UV移到0-1的空间之外d.这时候利用高模产生normal e.贴normal map到低模可得到完美效果.详情请看Normal Map法线贴图(一)里面的镜像（Mirroring)单元 · 切勿在烘培法线贴图以前就把模型对称的那一半删除 · 游戏引擎内, 第二层的normal map (称为detail map)可以把对称缝隐藏起来 · 中性蓝代表的是垂直于面的法线向量, 利用中性蓝来涂抹normal map上UV边缝可有效解决边缝产生的问题. · 对于硬边, 每个vertex会有两个vertex normal. 因此软边(整个相同的smooth group)比较不会有边缝的问题. · 有做bevel产生的normal map在模型的边的地方会比较漂亮 · 不要单纯地做extrude,要用bevel · mental ray Round Corners Bump可在算图时产生bevel效果 · cage的形状会影响到normal map产生的品质例如波浪效果 · 两张normal map叠在一起. 要用Crazy bump来做叠合会比较好, 因为他是真正用3D空间来对normal map进行混合叠加. · 法线是有长度的, 所以当两张normal map叠在一起, 他的长度可能会大于1, 因此必须进行重新标准化法线(Re-normalizing)的动作 · 就算算出来的法线贴图是正确的, 在3dsmax的硬体显示功能无法正确地显示法线贴图的效果. · 高模没有必要只做一块模型, 可以分成好几个零件","link":"/posts/Normal02/"},{"title":"Normalmap原理及去除接缝","text":"Normalmap原理及去除接缝在遇到Normal map上出现接缝时是十分棘手的。它不像Diffuse和Specular那样，可以直观的在ZB或者BodyPaint里用投射的方法去修平。这是因为Normal map本身原理所致。 在这里我想先再详细讲一下Normal Map的原理。如果你觉得自己对Normalmap已经非常熟悉可以跳过这一节。 ● NormalMap 原理： 我建议新手在得到一张NormalMap时，把Red/Green/Blue三个通道分开来看，因为NormalMap的三个通道之间是互相独立的，在R/G/B三个通道中，不同的灰度，表达了低模表面上法线偏移的程度。大家知道，法线在物理中的定义是垂直于物体表面的一条假想的直线。而在MAYA中，法线的概念并不一样，它不一定要垂直于物体表面，并且具有方向行。我们可以在MAYA中直观的看到物体上每个顶点的法线的方向。 ​ 显示顶点法线后的模型 [page] 我们可以选择顶点，用Edit Polygons-&gt;Normals-&gt;Vertex Normal Edit Tool试着调整顶点法线的偏移。来让模型看起来与现在不同。 经过这样调整法线方向以后，模型表面像增加了一个曲度。这种调整的原理类似于NormalMap对法线偏移的调整。只不过NormalMap能够调整模型上的每一处细节；但用这种方法，只能调整低模上有限的点。 如果我们建立了如下图的高低模，并烘焙出法线贴图。 那么实际上是把LowPoly表面的法线偏移方向调整成了HighPoly表面的法线方向。如下图。 [page] ● 结论和规律 我们再做一个简单的实验，测试了三色通道的具体含义，得出后面的结论。 这个是圆环模型 这个是用光照的方法生成的Normal 以下是R、G、B三个通道： Red通道 Green通道 由上图得出以下结论： 在红色通道里：白色表示法线向右偏，黑色表示法线向左偏。 在绿色通道里：白色表示法线向下偏，黑色表示法线向上偏。 在兰色通道里：越黑表示越深。 如果想把某出的Nomalmap填平，可以在上面覆盖一层RGB值为128、128、255的颜色，编号为:8080ff MAYA里Normalmap的绿色通道和MAX里Normalmap的灰度相反。 有了这些研究成果，以后修改Normal就方便多了。甚至可以手绘部分细节。 这样就可以得出下面的规律： 所有Normal贴图的红色通道，都是在水平方向上有黑白渐变。 所有Normal贴图的绿色通道，都是在垂直方向上有黑白渐变。 根据这个现象可以很容易的在通道里判断出哪里的Normal不正常，需要红绿通道交换。 [page] 修理Normalmap接缝 在做人物的时候如果遇到下图这样的接缝，最开始做的应该是弄清是哪张贴图产生的接缝，而不要盲目的直接去修Diffuse。正确的做法应该是排除其他贴图的干扰，单独贴上Diffuse， 修掉Diffuse上的接缝，再单独把 Specular贴到color上修掉接缝，最后再修Normalmap的接缝。 对于Diffuse和Specular上的接缝，可以很容易的用ZBrush的ZApplink插件修掉。但对于Normal上的接缝，是不能用直观的方法修掉的。因为接缝两边的法线偏移的值并不是相同的，也就是说，颜色是不同的。下面我们就来探讨一下如何去处Normalmap上的接缝，而不仅仅是用8080ff的颜色把所有细节涂平。 我们先排除其他贴图的干扰，只贴NormalMap，可以看到有一条明显的接缝。现在的法线看起来似乎是图上箭头所表示的趋势。在前一节已经探讨了Normalmap的原理。脖子后面接缝的产生也是因为左右两边法线偏移方向不对。我们要想修正这条接缝就是调整要Normalmap上的颜色，使接缝两边的法线方向一致。 ↑现在看上去的法线方向 ↑修改后应该达到的法线方向 所以要将左边绿色网格对应区域的法线向左偏，白色网格对应区域的法线向右偏。 [page] 根据“在红色通道里：白色表示法线向右偏，黑色表示法线向左偏。”的原则，要在红色通道里把绿色网格那边的Normalmap加深，白色网格那边的Normalmap减淡。这样就可以把接缝修掉了，而且不会损失Normalmap上的细节。如图： 在红色通道里把绿色区域接缝附近的Normalmap的减淡（上图），把白色区域附近的Normalmap的加深（下图）。 这样就把脖子后面的接缝修掉了。虽然看起来原理很复杂，但只要理解了每个通道所代表的含义，很直接的会想到在通道里用加深减淡的方法修正法线偏移。如果实在弄不清到底是用加深还是减淡，就先随便用加深或者减淡试一下，如果接缝变浅了那就对了。但记住，修接缝的时候一定要排除其他贴图的干扰，只贴一张图去修。最终修好的效果如图：","link":"/posts/Normal01/"},{"title":"手和颈部","text":"07.手和颈部 Abductor Pollicis longus,Ext Pollicis brevis,Ext Pollicis Longus注意1st Interosseous,控制食指。注意食指还有一条单独的肌腱，有时表面会看到食指上有并排的两根肌腱Ext.Indicis proprius是连向食指的一根筋，有时能看到食指上并排的两根筋Mastoid ProcessTemporal 颞骨Occipital protuberanceSplenius capitis 主要负责头部转动,Levator scapulae会鼓起对准耳洞,Scalenus ,OmohyoideusOmohyoideus穿过三角形的区域（Fossa筋膜）连接到肩胛骨注意sternal head（稍微厚些）和clavicular head（比较薄）之间的Supra-clavicular fossa minor（凹陷），也注意左右sternomastoid之间的凹陷注意图中男性的Splenius capitisHyoid和其他骨骼不连接的骨头,上面连接着很多肌肉，控制人的喉咙Hyoid Bone所在位置的面转折关系喉咙部位凸起的两处，Hyoid Bone和Thyroid cartilage(Adam’s apple)男性的喉结更凸起形状比较尖，女性稍圆滑在气管的两侧先是Sternohyoid,可以在很多人的气管两侧看到这条肌肉。再向外就是Omo-Hyoid,从Hyoid上向下，中间有一段变成筋，最后又是一小段肌肉连接到Scapula上3出凸起的地方Platysma 是非常薄的一层肌肉这边可以看到Platysam后方凸显出来注意脖子处Platysam不太容易发现左边是Splenius capitis","link":"/posts/rtjgbj07/"},{"title":"小腿和脚","text":"06.Proportions小腿和脚Lower legsLandmark :Head of the Tibia，Medial Melleolus,Lateral Melleolus，Calcaneus 先来说说gastrocnemius,Soleus,Soleus在下面，他们同时连接到肌腱上内头比较大，外头相对小而且平一些注意红色区域Flexor Digtorum longus和跟腱中间是空的膝盖弯曲的时候，后面会凹陷LateralTibialis anterior从侧面看，这块肌肉在胫骨这里形成一条弧线，Medial surface of Tibia有一定的弧度然后是Peroneus longus ,brevis,tertius(连接到fifth metatarsal)最后是夹在他们中间的Ext Digitorum longus从正面看，夹在Tibialis anterior和Ext digitorum longus中间的是Ext hallucis longus，控制大脚趾extensionperoneus longus在脚尖绷直的时候显现凹陷，当收回脚尖的时候回变的平坦DISSECTIONFeetBones and LandmarksLateral Malleolus, Medial malleolusTalus=TallestCalcaneusMetatarsal 注意the 5th metatarsalNavicular在Talus前部，自己可以摸一下脚，感觉到这块骨头CuboidAbductor hallucis 从1st metatarsal 到border of calcaneusAbductor digiti minimi像两节香肠。 Extensor tertius 连接到fifth metatarsal .Extensor hallucis longus控制大脚趾.Extensor digitorum brevis 在Extensor digitorum longus下方，有点像鸡蛋形状仔细观察图片，注意蓝色部位，最终会认识这些肌肉，再好好研究一下MRT，找出学过的肌肉肌腱和骨头大脚趾下的脂肪Extensor digitorum brevis在图中的egg ShapeMetatarsal 注意the 5th metatarsalExt.Digitorum brevis Ext.Hallucis brevis","link":"/posts/rtjgbj06/"},{"title":"盆骨和上半部分腿部","text":"05.Proportions盆骨和上半部分腿部 男性盆骨比女性盆骨高度要高，前后距离更大，女性盆骨更浅，宽度更宽先了解下knees的结构站立和弯曲腿的时候，Femurs的轴会前后滑动，但髌骨不会有太大的变动注意在髌骨和胫骨连接的韧带下有一些像云朵形状的脂肪再注意膝盖处几根韧带注意膝盖后面有个叫 popliteal Fossa,下面会有经脉和血管Sartorius and Tesor Fascia LataeSartorius 和Tensor Fascia Latae从Ant Sup Aliac Spine向下，形成一个倒过来的V，定好了这两块肌肉,相当于定好了边界线，腿部的其他肌肉位置就能勾勒出来了,Sartorius不会鼓起非常厉害，只是在四头肌和腿部后面的肌肉形成一个界线Sartorius最长的肌肉，从ANT.SUP,Aliac spine一直到胫骨外侧Ilio-tibial bandQuadriceps有点像Triceps,Vastus medialis,Vastus lateralis,Rectus femorisBand of RicherHamstrings注意Biceps femoris从侧面看可以作为一条直线Long head short head 这里注意landmark head of FibulaSemitendinosus,Semimembranosus这一部分基本是一个整体Adductors,etclliopsoasAdductor magnus, Adductor longusGluteus maximus Gluteus medius","link":"/posts/rtjgbj05/"},{"title":"Upper Arm 手臂上部","text":"Upper Arm 手臂上部 注意侧面观察肱骨头上半部分近似笔直，下半部分略微带有的弧度，下方靠近关节处逐渐变扁， 出现ridge(嵴)Biceps, Brachialis, Coraco Brachialis 二头肌、肱肌、喙肱肌Brachialis从Humeras连接到Ulna, Biceps一头连到Radius,另一头连接到皮肤上。因为Biceps连接尺骨、和桡骨，所以可以控制前臂的掌心向下和向上的反转动作注意胸大肌、三角肌和肱二头肌插入肱骨的位置掌心朝下时，Biceps处于拉伸状态，掌心向上时，Biceps呈现收紧状态，仔细观察不同状态下的肱二头肌侧面看起来，分成三等分从肘部开始，有一个肌腱，三头肌的外侧是一鸡蛋加一条尾巴的形状，看起来像个逗号“，”长头从肌腱上形成一个斜边，向上插入到肩胛骨的外延，插在大圆肌和三角肌中间。内侧三头肌比较扁，在最里面，表面被肌腱覆盖。此处要特别注意肌腱的形状和位置。这块肌腱不同的人会很不一样长头靠近腋下部分有一个平的地方，因为那里有一片肌腱在内侧的经脉也要注意，有时表面能够看到他们仔细观察上臂内侧的经脉和Coracobrachialis（喙肱肌）的位置关系,Teres major Latissimus Dorsi肌肉发达的健身者，把手臂用力伸直后，凸起的Triceps像一个马蹄铁的形状。放松肌肉的状态尤其是肌肉不发达的人看起来就像圆柱体。Forearms**前臂**Extensor 伸肌Ridge Muscles**嵴肌群**l Brachioradialisl Extensor Carpi Radialis LongusBrachioradialis 帮助前臂的弯曲名词注释：手腕部位的称之为CARPI 手指部位的称之为DIGITORUMLateral Epicondyle在Extensor carpi radialis插入出有个凹陷请注意Cubital fossa这个三角区域，在手腕和前臂向内旋转的时候，通常这个区域变的可见Brachioradialis 和Extensor carpi radialis longus 表面看起来会形成一个整体，比较难区分。他们形成了Radial muscles group,注意观察前臂向内旋转时（pronation），他们的形状。Brachioradiailis和Extensor Carpi Radialis longus从表面看起来是块整体。我们之前也提到过Cubital fossa,它位于两组肌群（Flexor,Extensor）的中间位置,在Biceps下方Brachioradiailis ,Extensor carpi radialis longus ,是ridge muscles肌肉从ridge of the Humerus向下再没到手腕就只有肌腱了ExtensorExtensor Digitorum,向下平均分成4条肌腱，控制4根手指的Extension,Extensor Digiti minimi控制我们的小拇指的ExtensionLIKE THIS最后是Extensor carpi ulnaris还要说一下Anconeus,一块三角形肌肉，从Lateral epicondyle 加固Ulna,所以Ulna不是笔直的从肱骨的脊旋转向下Flexor 屈肌首先来看**Flexor carpi radialis** 和**Flexor carpi ulnaris**然后中间比较细的是Palmaris Longus，当蜗居拳头手腕向内弯曲的时候，你可以看到三个筋。当然，世界上可能有10%的人看不到自己的Palmaris或只能看到一只手有，Palmaris Longus也不是左右手对称的最后来看一下，Pronator teres，它从medial epicondyle of humerus 连接到Radius。和前臂的anconeus对应拇指由另一组肌肉控制,他们在前臂靠近手腕部位，覆盖在许多肌腱上Abuctor pollicis longus,Extensor pollicis brevis另一根为Extensor pollicis longus，你在表面看不到他的肌肉形状，因为它被其他肌肉和肌腱覆盖，但你用力伸展拇指或做翘大拇指动作的时候，你可以看到一根肌腱来看一下解剖下的 Extensor和Flexor,Flexor在手臂正面会形成一大块","link":"/posts/rtjgbj04/"},{"title":"肩部和背部","text":"03.肩部和背部 Shoulders （肩部） Deltoid -三角肌由三块组成，前、中、后，各自独立，分别控制手臂向前抬起，侧面抬起和向后抬起。链接到Humers肱骨上最粗糙的地方，大约在肱骨的二分之一处注意图中 Deltoid tuberosity就是三角肌插入手臂的位置 DELTOID注意Medial Head ，叫做mutipennate,注意肌肉纤维的走向，因为medial head从acromin process 开始注意后束是连接在筋束上的TRAPEZIUS 斜方肌注意Trapezius连接到正面的外侧三分之一的ClavicleRhomboid 菱形肌Supra spinatus冈上肌 , Infra spinatus冈下肌 , Teres minor小圆肌 , and Teres major**大圆肌**Scapulo-humeral rythemSerratus Anterior 前锯肌从第二肋骨，一直到第九肋骨，有的人可能到第十肋。有的人8条digitations，有的人9条digitations，这都是遗传的.上部分的会被胸肌挡住，下部分朝向前方肋骨的会被观察到。往往在瘦的人身上比较能观察到，最下方3至4块肌肉在和肋骨连接处，形状比较圆，和肋骨对齐，此时腹外斜肌随着向下，变得越来越“斜”，最下方的3、4条digitations在Pectoralis major和Latissimus Dorsi之间形成一条曲线，奶头的位置在这条曲线轨迹上Latissimus Dorsi 背阔肌 （简称Lats）Latissimus Dorsi是非常薄的一片肌肉，当人们侧身的时候，往往肌肉下的肋骨会清晰可见。简称Lats,它的生长一部分从posterior iliac crest 的几乎最顶部分连接到Humerus注意aponeurosis（筋膜）,这是人体上很常见的由于Lats比较薄，人体在向前伸展的时候，你会看到背骨的肋骨，第10节肋骨到12节，瘦的人可能会看到第9肋，除此之外还会看到Serratus AnteriorLatissimus Dorsi 会盖住一部分Teres major这块肌肉不发达的人看起来是这样的仔细观察肋骨和肩胛骨，找出Rhomboid菱形肌,Teres major大圆肌和Latissimus dorsi背阔肌,Trapezius斜方肌Spinal Erectors 骶棘肌注意胸部、背部和手臂肌肉在腋下的穿插位置","link":"/posts/rtjgbj03/"},{"title":"胸部和腹部","text":"02.胸部和腹部Week 2Pectoralis Major 胸大肌 Pectoralis Minor 胸小肌男女胸部形状的差异Rectus Abdominis6块腹肌？or 4块腹肌？大多数人只有4块腹肌注意腹直肌从上到下的筋膜角度和不对称性External oblique从5th 肋骨开始向 Rectus会聚，一共八块，上面4和前锯肌交错称之为digitations简称digits，下面4块通常看成一块整体（Flank pad）连到 iliac crest上","link":"/posts/rtjgbj02/"},{"title":"人体比例和骨骼","text":"Proportions**01.人体比例和骨骼** ** Before the Beginning Some Bony Landmark you should know before the course A few naming note:解剖学中的一些术语 Anterior=Front 正面 Posterior=Back 背面 Superior=up 上部 Inferior=down 下部 Medial=Towards Center内侧 Lateral=Away from Center 外侧 Tendon=Muscle to Bone 筋（束） Ligament=Bone to Bone 韧带 人体骨骼上重要的Landmarks（标记位） Clavical锁骨 Medial epicondyle 内上髁 Lateral epicondyle 外上髁 Vertibra(SPINE)脊椎Vertebra一共由24快骨头组成，从上到下可以分为三个部分，上面的Cervical Vertebra（7节），中间的Thoracic Vertebra（12节）和底部的Lumbar Vertebra（5节不包含Sacrum），由细到粗Cervical Vertebra一共7块，第7节Cervical是重要的标记点，很多肌腱的连接位置都在这边。Rib cage（胸腔）由12根肋骨围成，也正好是Thoracic Vertebra的位置。向下为Lumbar Vertebra,这个骨头变得更大更粗壮些，因为他们要承受整个上半身的重量，相对其他骨头也更容易受伤损坏。最后要说到Pelvis（盆骨）,最后一节Sacrum（骶骨）连着Pelvis,Sacrum的尾骨叫做Coccyx，由尾巴进化而来。 Pelvis的标记，一个主要的是crest本身，Pelvis后半部分斜着隐藏，前半部分又会显现，从前面看，又两个重要的标记点，是Ant.sup.iliac.spine,当你刚开接触的时候，有可能不太喜欢这个名字，可能会憎恨，因为读起来太绕口了，但这些名字都非常有指向性意义的，我们得记住他们具体的学名。这些名字具有方向性和功能性的意义。ANT是anterior的缩写，表示正面，Sup是superior的缩写，表示上面 Pelvis前面要注意Pubic （耻骨），它是人的中等分位置，可以用它来检查比例是否正确。Pelvis的后面注意Ischial（坐骨）,腿部的肌肉和它相连 ARM手臂（Upper arm**上臂**）Humerus 肱骨 （**Fore arm**前臂）Ulna尺骨，Radius桡骨","link":"/posts/rtjgbj01/"},{"title":"古巴哈瓦那究竟有多美","text":"古巴哈瓦那究竟有多美 哈瓦那（La Habana）是古巴共和国的首都，是它最大城市，也是全国的经济和文化中心。哈瓦那地处热带，气候温和，四季宜人，有“加勒比海的明珠”之称，古老教堂、城堡、广场、博物馆、纪念碑、公园、图书馆等众多，为著名的旅游胜地。 哈瓦那分为旧城和新城两部分。其中，旧城拥有西方各个时期不同风格的建筑，包括许多殖民时期西班牙式的古老建筑。1982年，哈瓦那旧城区被联合国教科文组织列为世界上121个“人类文化财富”之一，并作为文化遗产被列入世界文化遗产名录。 整个色彩缤纷的旧城区是哈瓦那人气最高的景区，没有人去哈瓦那不会在老城区逛逛。马卡龙色系的古典的西方建筑，与灿烂的阳光一起构成一片充满热带风情的童话，俘获了许多少女心。 古巴国会大厦，1959年以前一直是古巴政府的办公大楼，现在是古巴科学院所在地。国会大厦是古巴最宏伟的建筑之一，建成于上个世纪30年代，整体采用新古典主义建筑风格，和美国国会大厦的灵感都来源于巴黎的先贤祠（Panthéon）。 老广场（la Plaza Vieja）是哈瓦那最受喜爱的广场。广场修建于16世纪，曾经是个露天集市。东北角有暗厅（Cámara Oscura），最早是由达·芬奇设计、西班牙的众议员卡迪斯捐赠的。在那里，光线通过一个镜面反射到 一个有凹陷的屏幕上，能够看到半径5公里之内的景色。 作为滨海城市，哈瓦那海岸线在MV里也十分抢镜。一边是楼房林立，一边是海浪拍岸，蔚为壮观。 古巴的自然风光吸引力不亚于建筑和老爷车。蓝天、碧海、椰林、沙滩，使它成为了非常受欢迎的度假胜地。 1959年古巴革命后，美国对古巴展开了经济封锁，禁止向古巴出口汽车。于是，哈瓦那便像一个时间胶囊一样，大街上跑着许许多多50年代的老爷车，成为了一道独特的风景线。 与众多拉美地区一样，在古巴，音乐和舞蹈都在当地深受喜爱。哈瓦那国际芭蕾舞节是舞蹈界的盛事，每两年举行一次。 除了音乐和舞蹈，酒在古巴也深受喜爱。周杰伦歌曲中的mojito(莫吉托)就是一种起源于古巴的鸡尾酒，有传说是著名作家海明威发明的。不管这个传说是不是真的，说过“我的莫吉托在La Bodeguita”的海明威都对它的喜爱都不容置疑。 古巴几乎没有网络，但这也使得去那里生活工作的人得到一段分外难忘的经历——能够静下心来享受那里的阳光、海岸、老城，与当地热情淳朴的人相处。","link":"/posts/f8687df7/"},{"title":"人体结构图，讲解得很细致","text":"人体结构图，讲解得很细__体块","link":"/posts/f17e1d56/"},{"title":"最到位的人体结构分析必备","text":"最到位的人体结构分析，必备这一组人体结构分析 吸收学习吧 老王只能帮你到这儿了","link":"/posts/16410305/"},{"title":"重装系统后hexo写博客功能的恢复","text":"重装系统后hexo写博客功能的恢复前两天重新给电脑装了个win10，之前存放在C盘的里面的hexo全部没有了，折腾了半天，终于恢复了hexo写博客的功能，现在记录下来，给需要的朋友备用。 对于hexo来说，两个配置文件是最重要的，一个是hexo本身的配置文件，位于”你的hexo主目录/“下的”_config.yml”，另一个是主题的配置文件，位于”你的hexo主目录/themes/你的主题文件夹/_config.yml”，这两个文件一定要记得备份，如果没有了，那就只能重新配置了。另外就是source文件夹下的博客文章资源等，也应该做好备份。如果没有备份，那么恢复hexo的发博客功能也是没有关系的，但是配置上和博客文档上可能需要自己重新配置了。 首先声明，以下所有的操作都假定你之前的hexo已经配置好，博客系统可以正常工作，只是因为重装系统或者其他操作失去了本地的hexo文件夹，现在要恢复hexo而已，并且以下都是基于windows系统的。 安装git和nodejs这两个软件是hexo可以正常工作的基础，必须要先安装好。安装后，要在cmd命令行执行node -v和npm -v检查是否安装成功。 安装hexo如果git和npm都已经安装好了，那么现在可以直接安装hexo了，在命令行中执行以下命令：npm install -g hexo-cli 将hexo安装到全局。 建立hexo文件夹在自己选定的某个目录下，新建一个文件夹，这个文件夹就是之前的hexo文件夹，可以命名为’hexo’。进入hexo文件夹，按住shift加鼠标右键，选择“在此处打开命令窗口”（或者直接通过cmd进入此文件夹也可），在打开的命令行窗口中执行： 1hexo init 此命令执行完成后，会在该文件夹下生成多个文件，这是hexo的基本文件，然后继续执行： 1npm install 安装hexo必须的依赖包。安装时可能会有一些warning的提示，但一般不会影响使用。可以进入node_modules文件夹查看安装的依赖包情况。至此hexo文件夹的基础部分就恢复了。 如果备份了hexo的配置文件_config.yml，可以直接将文件复制过来覆盖，如果没有备份，那么就只能自己重新配置了。 恢复主题先在网上搜索自己需要恢复的主题的github链接，进入hexo/themes文件夹，鼠标右键，选择”Git Bash Here”，打开git窗口，执行 1git clone http://你找到的gitbub链接 克隆完成后，进入该主题的文件夹。如果之前备份了主题的_config.yml文件，则直接复制过来覆盖。hexo的_config.yml文件和主题的_config.yml不是同一个文件，前面已经提过。如果没有备份，那么只能重新配置一遍。 测试本地至此，本地的配置已经完成了，可以先进行简单的本地测试。进入hexo文件夹，打开命令行窗口，或着打开Git的命令行窗口也可，执行： 1hexo g 此时可以看到hexo在执行生成页面文件，再执行 1hexo s hexo启动本地服务，浏览器中输入’http://localhost:4000/‘，可以看到在本地的预览效果。至此，说明本地的配置已经完成。 恢复与github的链接恢复到github有以下几个步骤： 配置_config.yml中的deploy在hexo根目录下的_config.yml文件中，要配置deploy（如果是之前已经备份的则不需要改变，如果是重新写那么先要配置这个选项），格式为： 1234deploy: type: git repository: git@github.com:yourname/yourname.github.io.git branch: master 配置公钥一般来说，重装系统后并没有配置SSH Keys，所以还要配置SSH Key。在hexo文件夹中点击鼠标右键选择“Git Bash Here”打开命令行窗口，执行以下命令： 1$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; 此时会看到窗口显示以下信息 12Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): 要求用户选择公钥的存放路径，可以手动定制，也可以直接回车放在默认的路径，后面要用到这个路径。然后，系统会要求用户输入密码： 12Enter passphrase (empty for no passphrase):&lt;输入加密串，回车&gt;Enter same passphrase again:&lt;再次输入加密串，回车&gt; 此时命令行窗口会显示以下内容： 说明公钥已经生成。 添加公钥到Github：找到刚刚生成的公钥文件，文件名为id_rsa.pub。如果是自定义的公钥存放路径那是在该目录下，否则是默认的路径下。在我的win10系统中，默认路径是在’C:Userscattle.ssh’目录下，cattle是我的windows用户名，如果在win7系统，应该在’C:Documents and SettingsAdministrator.ssh’，如果实在找不到，在上面公钥生成后的提示中也可以找到，如上面的截图中的第一句就是路径信息，如果你把窗口关了，好吧，按照文件名搜一下吧。找到这个文件，用文本编辑器打开。 登录到Github，点击头像，在下拉菜单中选择Account Settings–&gt;SSH Public keys –&gt; add another public keys，会弹出一个文本框，title随意填写，然后复制文本编辑器中的内容，直接复制粘贴到Key中，点击Add key按钮即可。 设置用户信息用户信息被Github用来记录提交信息。执行以下命令： 12$ git config --global user.name &quot;cnfeat&quot;//用户名$ git config --global user.email &quot;cnfeat@gmail.com&quot;//邮箱 至此，已经完成了到Github的连接。 添加CNAME和README文件此时，如果直接执行hexo g和hexo d，按照提示输入密码，就可以部署了。但是在浏览器中输入域名打开时会提示404，原因是缺少CNAME文件。 在hexo/source文件夹下，新建一个文本文件，里面的内容是域名，如’liugui.me’，然后保存，关闭，选中点击右键，属性，将文件名改成CNAME，去掉后缀，弹出的提示框直接选是。 另外，一般还需要一个README文件，同样是新建文本，内容自己写，是描述自己的博客的，然后修改属性，去掉后缀。注意，千万不要把后缀改成md，这样会编译成一个HTML文件。 重新执行以下命令： 12hexo ghexo d 然后，在浏览器中可以打开了。 小结至此，已经完成了全部操作。提醒大家平时要备份配置文件，这样以后恢复的时候就方便多了。","link":"/posts/3a297cd4/"},{"title":"Youtube视频下载链接获取器","text":"#介绍最近想通过youtube来学习英语，但是学校网速渣，在线看太卡，就写了这一个小工具来获取视频和字幕的下载链接。字幕支持中英文下载。视频下载清晰度是youtube提供的，不同的视频有不同 的支持列表。#地址##Youtube视频下载链接获取器#说明这个工具仅仅是获取下载链接，前提是你能够访问youtube，方法很多： goagent shadowsocks VPN 等等 #使用帮助访问工具的地址，然后粘贴你观看的youtube视频的地址，获取地址的方法有： 从视频的地址栏获取 在视频上右键“获取视频地址” 得到的是形如： https://www.youtube.com/watch?v=zqKovGMx9xo 的地址，只需要复制粘贴进输入框，提交即可。在结果页面中，将得到形如下图的的结果，点击下载链接即可下载，或者复制链接到你的下载工具也可以。 #Thankszukasmichael的项目，很大程度上的帮助keepsubs一个视频字幕下载网站","link":"/posts/20d94ec7/"},{"title":"Shadowsocks科学上网","text":"[TOC]自己配了下试了试，发现速度比goagent快了不止一点，当然和hosts相比，有些hosts的ip飞速，有些龟速，但是hosts一般是没法观看youtube的。 配置环境准备##美国低价VPS购买和使用教程 服务器配置##首先确保安装了python2.6或者2.7： 检查版本： --version```1##安装软件包（这里的命令，记得一条一条跑） apt-get update &amp;&amp; apt-get install build-essential python-pip python-m2crypto python-dev pip install gevent shadowsocks 12##创建配置文件：下面是两条命令，第一条创建文件，第二条用vi编辑器编辑文件： touch shadowsocks.jsonvi shadowsocks.json 123此时会进入这样的界面![][4]下面是shadowsocks配置文件的介绍： {“server”:”服务器 IP 地址”, #VPS的IP地址“server_port”:8388, #监听的端口“local_address”: “127.0.0.1”, #本地监听的IP地址，默认为主机“local_port”:1080, #本地监听的端口“password”:”mypassword”, #服务密码“timeout”:300, #用于加密的密码“method”:”aes-256-cfb”, #加密方法，推荐 “aes-256-cfb”“fast_open”: false, #是否使用 TCP_FASTOPEN, true / false“workers”: 1 #worker 数量，Unix/Linux 可用，如果不理解含义请不要改} 1去掉所有的注释，并且修改服务器IP地址和密码，如下（注意修改server的ip和password的密码成自己的）： {“server”:”123.45.67.8”,“server_port”:8388,“local_address”: “127.0.0.1”,“local_port”:1080,“password”:”mypassword”,“timeout”:300,“method”:”aes-256-cfb”,“fast_open”: false,“workers”: 1} 1234567复制上面的信息，在putty的窗口中点击鼠标右键，信息就被粘贴进去了，但是开头的信息有些遗漏，如下：![][5]注意，此时左下角有个`-- INSERT --`的白字,按方向键移动光标到第一行，然后按delete键删除错误的信息，对照着上面修改成正确的，修改完成之后是这样的：![][6]然后按下`ESC`键，白字消失，输入`:wq`注意是英文冒号，然后回车，就退回了命令行。##配置开机启动项输入 vi /etc/rc.local 1234在最后的`exit0`之前添加下面一行：&gt;nohup /usr/local/bin/ssserver -c /root/shadowsocks.json &amp;和上面一样的编辑方式，wq保存之后，输入重启服务器的命令： reboot 123456789101112131415此时终端会自动关闭。服务器已经配置好了#客户端配置##win下配置下载这个文件https://github.com/shadowsocks/shadowsocks-csharp/releases选择Shadowsocks-win-2.3.1.zip如果打不开,从[百度网盘分享][7]也行就一个简单的文件，解压出来，打开运行，填入参数：![][8]## linux（以ubuntu为例）：各发行版linux shadowsocks安装方法找官网的说明，python版本的安装可以直接用 sudo pip install shadowsocks 1234提示有缺什么就安什么。这里说下配置方法：在自己喜欢的地方新建一个配置文件：文件内容 {“server”:”服务器 IP 地址”, #VPS的IP地址“server_port”:8388, #监听的端口“local_address”: “127.0.0.1”, #本地监听的IP地址，默认为主机“local_port”:1080, #本地监听的端口“password”:”mypassword”, #服务密码“timeout”:300, #超时设置“method”:”aes-256-cfb” #加密方法，推荐 “aes-256-cfb”} 12同样，记得把注释删掉然后按照上面的方法修改系统启动项重启即可 nohup /usr/local/bin/sslocal -c /你自己定义的配置文件的路径/shadowsocks.json &amp; 12345678910111213141516171819##android和ios则需要去应用市场搜索shadowsocks，安装即可。或者用fqrouter2。## 桌面浏览器配置（移动端当然不用配置浏览器）以chrome为例：先去chrome应用商店搜索这个拓展SwitchyOmega，如果上不去，可以先参考这里替换hosts：[修改hosts使用google应用商店][9]安装插件成功以后，在情景模式里新建情景模式为shadowsocks（这是你建立的情景模式的名字），协议选择sock5,服务器输入127.0.0.1,端口是1080,就是和前面下载的那个软件里的配置一样，左下角保存更改。设置规则列表更新，如果没有东西，那么输入：&gt;http://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt打开百度，点击chrome浏览器右上角的新安装的插件的图标，选中自动切换。然后登录facebook.com试试吧。#附加tips##update 2015.2.5 linux下可以用**proxychains**来对某个命令进行单独翻墙。比如```proxychains git push origin master win下的gui客户端可以直接设置全局翻。","link":"/posts/8bc50cb8/"},{"title":"Markdown插入数学公式","text":"[TOC]自从使用Markdown以来，就开始一直使用Markdown+Github在写文章，整理自己的所学所思。本文亦是通过这种方式完成的。 然而，Markdown自由书写的特性很好，唯独遇到数学公式时就要煞费苦心——每次都是先使用Latex书写(在线的Latex编辑器参考1)，然后保存为图片，使用img标签进行引用，当公式很多的时候稍显复杂。 本文的方法使用html的语法，调用1的公式生成API，在线生成Latex数学公式，免去将公式保存为图片的麻烦。当然，弊端也是有的，公式太多，可能会造成刷新比一般的网页慢一些。#方法一：使用Google Chart的服务器 1&lt;img src=&quot;http://chart.googleapis.com/chart?cht=tx&amp;chl= 在此插入Latex公式&quot; style=&quot;border:none;&quot;&gt; 一个例子， 1&lt;img src=&quot;http://chart.googleapis.com/chart?cht=tx&amp;chl=\\Large x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}&quot; style=&quot;border:none;&quot;&gt; 公式显示结果为： 适用了下，Google Chart服务器的响应速度还可以，但据说可能复杂一些的Latex公式可能无法解析（参考[2]）。#方法二：使用forkosh服务器 forkosh上提供了关于Latex公式的一份简短而很有用的帮助，参考1和[3]. 使用forkosh插入公式的方法是 1&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? 在此处插入Latex公式&quot;&gt; 给个例子， 1&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi? \\Large x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}&quot;&gt; 显示结果为：因为网页插入公式的原理是调用“某某网站的服务器”动态生成的，所有保证公式正常显示的前提是该网址能一直存在着为我等小生做些小小的服务。forkosh我是用了快2年了，一直很好，推荐！ #方法三：使用MathJax引擎 大家都看过Stackoverflow上的公式吧，漂亮，其生成的不是图片。这就要用到MathJax引擎，在Markdown中添加MathJax引擎也很简单， 1&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt; 然后，再使用Tex写公式。$$公式$$表示行间公式，本来Tex中使用\\(公式\\)表示行内公式，但因为Markdown中\\是转义字符，所以在Markdown中输入行内公式使用\\\\(公式\\\\)，如下代码： 12$$x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$$\\\\(x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}\\\\) 分别显示结果（行间公式）： $$x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$$ 行内公式：\\(x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}\\) 不信，你可以试一下，在公式上还可以使用鼠标右键操作。 #参考 [1] http://www.forkosh.com/mathtextutorial.html [2] http://www.ruanyifeng.com/blog/2011/07/formula_online_generator.html [3] http://www.forkosh.com/mathtex.html #转载自：http://blog.csdn.net/xiahouzuoxin/article/details/26478179","link":"/posts/c491f8e4/"},{"title":"github学习笔记","text":"##安装与配置 123456sudo apt-get install git git config --global user.name &quot;Your Name Here&quot;git config --global user.email &quot;your_email@example.com&quot;//设置让credential helper 帮助我们在一定的时间内在内存中保存我们的代码，其中第二行的命令是设置超时的时间（两句分别执行）git config --global credential.helper cachegit config --global credential.helper 'cache --timeout=3600' ##项目建立与更新###新建立空的项目先建立一个目录，该目录名跟你新建立的repository有关，命令如下(一行一个命令)： 12345678910111213mkdir ~/Hello-World //（其中的hello0-World就是你新建立的repository的名称）cd ~/Hello_Worldgit init //(初始化一个空的Git repository )touch README //README 暂时写入“hello world”(建立一个文件，README文件的主要用途是描述项目或者一些加入信息的文档，例如关于如何安装该项目或者怎么使用这个项目)//提交刚加入的文件README,命令如下(下面的两步是不能省略的，文件名可以改为你想要提交的文件名)：git add READMEgit commit -m 'first commit'push 提交(这里提交的方式是使用http的方式，也有ssh的提交方法，这里面就不做介绍了)git remote add origin https://github.com/username/Hello-World.git //(其中的https://github.com/username/Hello-World.git，是该项目的http,这可以在网页上得到，复制过来即可)//之后会要求输入用户名和密码。提交的命令是：git push origin master github上的提示 12345678910111213Create a new repository on the command linetouch README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/Findxiaoxun/smartpellow.gitgit push -u origin masterPush an existing repository from the command linegit remote add origin https://github.com/Findxiaoxun/smartpellow.gitgit push -u origin master ###远端已经存在的项目先clone下来 git clone https://github.com/username/Hello-World.git然后更新之后add，push###本地已经存在的项目 123git remote add origin https://github.com/username/Hello-World.git $git fetch origin //获取远程更新$git merge origin/master //把更新的内容合并到本地分支 然后再git push origin masterReference： http://www.cnblogs.com/Findxiaoxun/p/3574427.html ##撤销###撤销本地还未提交到远端的commit本地直接： git reset –hard HEAD~2 表示恢复到2次提交以前，这里是本地的恢复。远端此时并没有改变，此时commit是不行的，会提示你落后于远端###撤销已经提交到远端的 git push origin HEAD –force 这就是强行推送了。###Git的一些常用的撤销提交版本的的命令： git revert HEAD 撤销前一次 commitgit revert HEAD^ 撤销前前一次 commitgit revert commit （比如：fa042ce57ebbe5bb9c8db709f719cec2c58ee7ff）撤销指定的版本，撤销也会作为一次提交进行保存。revert 后要submmit ~ 修改最后一次提交 git commit –amend##推送到不同的远端比如我要同时推送到github和gitoschina。###直接修改config文件：[remote “origin”]url = ssh://server.example.org/home/ams/website.giturl = ssh://other.exaple.org/home/foo/website.git这样，每次push origin master的时候，会一个一个问你帐号和密码来推送###添加不同的名字 git remote add origin xxxgit remote add another yyygit push origin mastergit push another master 如果所在的地方github被墙了，可以用这个方法，然后利用翻墙单独推送github的。##一些错误###Github “fatal: remote origin already exists” 解决办法 最近遇到这个问题, 可以采用直接修改config文件的方法, 首先, 显示隐藏文件, 进入 .git/ 目录, 目录下面有一个 config文件, 以文本文件方式打开该文件, 在后面添加 [remote “origin”]url =项目的git地址即可.###更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。可以输入：git push -f","link":"/posts/82dfa1e4/"},{"title":"Gitee图床+PicGo+Typora便捷在博客中使用图片","text":"将Gitee仓库作为图床，使用PicGo进行图片上传与管理。 为什么要使用图床# 在hugo中，图片是以/static为基准目录的，例如，设baseUrl为https://focksor.gitee.io/，图片文件存放位置是static/img/gitee/123.jpg，那么，编译完成后页面图片引用的地址就是https://focksor.gitee.io/img/gitee/123.jpg，则在Markdown要引用此图片应该用![图片说明](/img/gitee/123.jpg)，但是这样带来的问题是，在写作的时候无法看到图片，要经过hugo编译之后才能看到文档图片，这样的写作显然是不友好的。 图床指存储图片的服务器，使用图床存储文档中的图片，那么在使用图片的时候只要写上图片所在的网络地址就好了，这样比较使用静态图片体验显然要好很多。下面介绍Gitee+PicGo的方法来使用gitee作为图床。 为什么需要PicGo#想象一下，使用markdown编写你的博客时，插入截图是什么流程：将截图保存到本地文件夹-&gt;将图片文件上传到网络服务器中-&gt;复制图片的网络地址-&gt;在markdown中输入![](图片的网络地址)，这个过程无疑是很繁琐的，而且如果你图片一多，这种过程将会是魔鬼体验。 PicGo是一款免费的图床管理应用，支持拖拽上传，剪切板上传等方式。你可以用它快捷地将图片上传到图床并获得网络链接，而且你可以设置链接格式为markdown，这就意味着你只要直接粘贴到markdown编辑器就可以插入图片了。 安装PicGo#访问PicGo的官方文档以了解PicGo的基本安装和使用方法。如果不想读文档的话，访问PicGo Releases直接下载你的操作系统对应的安装包并完成安装。 注：在安装的时候安装目录千万不能选C:\\Program Files\\下的任何地方，因为PicGo无法解析这一路径，如果你不知道安装在哪里的话，选择仅为我安装，否则在设置Typora时会出现以下错误： Copy failed to launch PicGo app: Command failed: C:\\Program Files\\PicGo\\PicGo.exe 'C:\\Program' �����ڲ����ⲿ���Ҳ���ǿ����еĳ��� ���������ļ��� 如下图所示 安装npm#由于PicGo的插件需要使用npm进行安装，如果你的电脑上没有安装npm，那么你是无法安装PicGo插件的，而我们接下来要使用一个额外的插件获得gitee支持，所以在此之前先完成npm的安装。 访问node.js的官网，根据官网的指导下载并安装node.js，如果你不想访问的话，点击此处下载，确认安装成功并更换镜像源： Copy PS C:\\Users\\focks&gt; node -v v12.16.1 PS C:\\Users\\focks&gt; npm config set registry https://registry.npm.taobao.org 设置PicGo用Gitee作为图床#运行PicGo，单击插件设置，在搜索中输入github，安装搜索结果中的github-plus，如下图所示。 在等待安装完成的过程中，移步gitee并创建一个仓库，仓库名随意，但是必须要是公开的仓库，这样图片才能被外部访问。我创建的仓库地址为https://gitee.com/focksor/giteePagesImgs，下文以该地址举例。 作为图床的仓库，一定不能勾掉管理界面的在线编辑 是否允许仓库文件在线编辑选项，否则使用PicGo管理的时候会导致操作被403 Forbidden。 创建完仓库后，还要创建一个私人令牌，私人令牌是用来允许PicGo访问并更新你的仓库的，这个时候，你已经明白了PicGo的运行原理：PicGo将图片上传到你的gitee仓库，然后返回给你图片的具体地址，这样你用该地址便可以访问到位于仓库的图片了。 创建私人令牌步骤如下：访问新建Gitee令牌，在私人令牌描述中写上便于你了解该令牌用处的文字，并勾选需要的权限，PicGo要使用的私人令牌只需要user_info和projects权限，勾选上后提交，gitee将会返回私人令牌的token，保存该token，因为该token只会出现一次，离开页面过后再不会出现。 回到PicGo，点击图床设置-&gt;githubPlus，在设置中填入repo和token，并选择origin为gitee，即可完成设置。其中，repo要填入owner/repoName，例如，仓库地址为https://gitee.com/focksor/giteePagesImgs，则`repo`填入的内容为`focksor/giteePagesImgs`。 上传和管理图片#单击上传区，选择链接格式，使用点击上传或剪贴板图片上传，PicGo会自动上传图片并将符合链接格式的链接复制到剪贴板，你只要按下Ctrl+v即可粘贴图片的链接。 单击相册，你可以看到你上传的所有图片，你可以对所有图片进行复制链接，修改图片URL与删除操作，并可以批量复制或批量删除。 要注意的是，gitee支持外部链接的文件大小限制为1M（不过我也没试过）。 使用Typora+PicGo体验更便捷的写博客姿势#如果你使用Typora作为博客文章编辑器，我建议你使用Typora+PicGo体验更便捷的写博客姿势，如果不是，我建议你使用Typora作为你的博客文章编辑器。如果你不听建议，你可以当我没说。 使用PicGo有效避免了使用图片时候的上传-&gt;编写markdown代码的步骤，但是我们能不能把添加到PicGo这一步也省略掉呢？答案当然是可以，Typora内置了使用PicGo自动上传图片的功能，也就是说，在需要使用图片的时候，你只要直接将图片粘贴到Typora就好了，这样就跟使用本地图片的体验毫无差距了。 设置Typora# 点击Typora左上角的文件-&gt;偏好设置 在弹出的界面中定位到图像，选择插入图片时选项为上传图片，并勾选对网络位置的图片应用上述规则 设置完成如图所示 选择上传服务为PicGo(app)，点击验证图片上传选项，如果出现如下图所示界面，说明配置已成功，然后你就可以直接在Typora中插入图片了，Typora会自动上传并替换图片地址为网络地址。 如果出现如下错误，请参考安装PicGo Copy failed to launch PicGo app: Command failed: C:\\Program Files\\PicGo\\PicGo.exe 'C:\\Program' �����ڲ����ⲿ���Ҳ���ǿ����еĳ��� ���������ļ��� 如果出现以下错误，点击PicGo界面左侧的PicGo设置-&gt;设置Server，并按下图设置 Copy Failed to fetch","link":"/posts/14be0bea/"},{"title":"MarkDown教程","text":"标题1# 标题名字（井号的个数代表标题的级数） 一级标题使用1个#二级标题使用2个#三级标题使用3个#四级标题使4用个#五级标题使用5个#六级标题使用6个######## 最多支持六级标题# 文字删除线1这就是 ~~删除线~~ (使用波浪号) 这就是 删除线 (使用波浪号) 斜体1这是用来 *斜体* 的 _文本_ 这是用来 斜体 的 文本 加粗1这是用来 **加粗** 的 __文本__ 这是用来 加粗 的 文本 斜体+加粗1这是用来 ***斜体+加粗*** 的 ___文本___ 这是用来 斜体+加粗 的 文本 下划线下划线是HTML语法 下划线 下划线(快捷键command+u，视频中所有的快捷键都是针对Mac系统，其他系统可自行查找) 高亮（需勾选扩展语法）1这是用来 ==斜体+加粗== 的文本 这是用来 ==斜体+加粗== 的文本 下标（需勾选扩展语法）12水 H~2~O 双氧水 H~2~O~2~ 水 H2O 双氧水 H2O2 上标（需勾选扩展语法）12面积 m^2^ 体积 m^3^ 面积 m^2^体积 m^3^ 表情符号 Emoji 支持表情符号，你可以用系统默认的 Emoji 符号（ Windows 用户不一定支持，自己试下~）。 也可以用图片的表情，输入 : 将会出现智能提示。 一些表情例子123:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile: :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary::+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger: :smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile: :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary: :+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger: ( Mac: control+command+space点选) 表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行： 1234name | price--- | ---fried chicken | 19cola|5 为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。 name price fried chicken 19 cola 5 为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界，在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式： 1234| name | price || :------------ | :---: || fried chicken | 19 || cola | 32 | name price fried chicken 19 cola 32 使用快捷键command+opt+T更方便(段落→表格→插入表格，即可查看快捷键) 引用1&gt;“后悔创业” “后悔创业” 12&gt;也可以在引用中&gt;&gt;使用嵌套的引用 也可以在引用中 使用嵌套的引用 列表无序列表–符号 空格123* 可以使用 `*` 作为标记+ 也可以使用 `+`- 或者 `-` 可以使用 * 作为标记 也可以使用 + 或者 - 有序列表–数字 . 空格1231. 有序列表以数字和 `.` 开始；3. 数字的序列并不会影响生成的列表序列；4. 但仍然推荐按照自然顺序（1.2.3...）编写。 有序列表以数字和 . 开始； 数字的序列并不会影响生成的列表序列； 但仍然推荐按照自然顺序（1.2.3…）编写。 1可以使用：数字\\. 来取消显示为列表（用反斜杠进行转义） 代码代码块1​```语言名称 12public static void main(String[] args) { } 行内代码123也可以通过 ``，插入行内代码（` 是 `Tab` 键上边、数字 `1` 键左侧的那个按键）：例如 `Markdown` Markdown 转换规则代码块中的文本（包括 Markdown 语法）都会显示为原始内容 分隔线可以在一行中使用三个或更多的 *、- 或 _ 来添加分隔线（``）： 123***------___ 跳转外部跳转–超链接格式为 [link text](link)。 1[帮助文档](https://support.typora.io/Links/#faq) 帮助文档 内部跳转–本文件内跳（Typora支持）格式为 [link text](#要去的目的地--标题）。 1[我想跳转](#饼图（Pie）) Open Links in Typora You can use command+click (macOS), or ctrl+click (Linux/Windows) on links in Typora to jump to target headings, or open them in Typora, or open in related apps. 我想跳转 自动链接使用 &lt;&gt; 包括的 URL 或邮箱地址会被自动转换为超链接： 123&lt;https://www.baidu.com&gt;&lt;123@email.com&gt; https://www.baidu.com 123@email.com 图片1![自己起的图片名字](图片地址或者图片本地存储的路径) 网上的图片1![friedChicken](https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1580814517&amp;di=2630beac440e5dab0e44c7286a3b2b61&amp;src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg) 本地图片123![friedChicken](friedChicken.jpg)在同一个文件夹里（用相对路径）或者直接拷贝 利用Markdown画图（需勾选扩展语法） markdown画图也是轻量级的，功能并不全。 Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。Mermaid 作为一个使用 JS 渲染的库，生成的不是一个“图片”，而是一段 HTML 代码。 （不同的编辑器渲染的可能不一样） 流程图(graph)概述12graph 方向描述 图表中的其他语句... 关键字graph表示一个流程图的开始，同时需要指定该图的方向。 其中“方向描述”为： 用词 含义 TB 从上到下 BT 从下到上 RL 从右到左 LR 从左到右 T = TOP，B = BOTTOM，L = LEFT，R = RIGHT，D = DOWN 最常用的布局方向是TB、LR。 1234graph TB; A--&gt;B B--&gt;C C--&gt;A 1234graph TB; A--&gt;B B--&gt;C C--&gt;A 1234graph LR; A--&gt;B B--&gt;C C--&gt;A 1234graph LR; A--&gt;B B--&gt;C C--&gt;A 流程图常用符号及含义节点形状 表述 说明 含义 id[文字] 矩形节点 表示过程，也就是整个流程中的一个环节 id(文字) 圆角矩形节点 表示开始和结束 id((文字)) 圆形节点 表示连接。为避免流程过长或有交叉，可将流程切开。成对 id{文字} 菱形节点 表示判断、决策 id&gt;文字] 右向旗帜状节点 单向箭头线段：表示流程进行方向 id即为节点的唯一标识，A~F 是当前节点名字，类似于变量名，画图时便于引用 括号内是节点中要显示的文字，默认节点的名字和显示的文字都为A 1234567graph TB A B(圆角矩形节点) C[矩形节点] D((圆形节点)) E{菱形节点} F&gt;右向旗帜状节点] 1234567graph TB A B(圆角矩形节点) C[矩形节点] D((圆形节点)) E{菱形节点} F&gt;右向旗帜状节点] 12345graph TB begin(出门)--&gt; buy[买炸鸡] buy --&gt; IsRemaining{\"还有没有炸鸡？\"} IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack(回家) IsRemaining --没有--&gt; sad[\"伤心\"]--&gt; goBack 12345graph TB begin(出门)--&gt; buy[买炸鸡] buy --&gt; IsRemaining{&quot;还有没有炸鸡？&quot;} IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack(回家) IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack 连线12345678910111213graph TB A1--&gt;B1 A2---B2 A3--text---B3 A4--text--&gt;B4 A5-.-B5 A6-.-&gt;B6 A7-.text.-B7 A8-.text.-&gt;B8 A9===B9 A10==&gt;B10 A11==text===B11 A12==text==&gt;B12 12345678910111213graph TB A1--&gt;B1 A2---B2 A3--text---B3 A4--text--&gt;B4 A5-.-B5 A6-.-&gt;B6 A7-.text.-B7 A8-.text.-&gt;B8 A9===B9 A10==&gt;B10 A11==text===B11 A12==text==&gt;B12 12graph TB A ---B 子图表使用以下语法添加子图表 123subgraph 子图表名称 子图表中的描述语句...end 1234567graph TB subgraph 买炸鸡前 begin(出门)--&gt; buy[出门买炸鸡] end buy --&gt; IsRemaining{\"还有没有炸鸡？\"} IsRemaining --没有--&gt; sad[\"伤心\"]--&gt; goBack(回家) IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack 1234567graph TB subgraph 买炸鸡前 begin(出门)--&gt; buy[出门买炸鸡] end buy --&gt; IsRemaining{&quot;还有没有炸鸡？&quot;} IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack(回家) IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack 序列图(sequence diagram)概述123sequenceDiagram [参与者1][消息线][参与者2]:消息体 ... sequenceDiagram 为每幅时序图的固定开头 1234sequenceDiagram Title: 买炸鸡 救救-&gt;&gt;炸鸡店小哥: 还有炸鸡吗？ 炸鸡店小哥--&gt;&gt;救救: 没有，要现炸 1234sequenceDiagram Title: 买炸鸡 救救-&gt;&gt;炸鸡店小哥: 还有炸鸡吗？ 炸鸡店小哥--&gt;&gt;救救: 没有，要现炸 参与者（participant）传统时序图概念中参与者有角色和类对象之分，但这里我们不做此区分，用参与者表示一切参与交互的事物，可以是人、类对象、系统等形式。中间竖直的线段从上至下表示时间的流逝。 12345sequenceDiagram participant 参与者 1 participant 参与者 2 ... participant 简称 as 参与者 3 #该语法可以在接下来的描述中使用简称来代替参与者 3 participant &lt;参与者名称&gt; 声明参与者，语句次序即为参与者横向排列次序。 消息线 类型 描述 -&gt; 无箭头的实线 –&gt; 无箭头的虚线 -&gt;&gt; 有箭头的实线（主动发出消息） –-&gt;&gt; 有箭头的虚线（响应） -x 末端为叉的实线（表示异步） –x 末端为叉的虚线（表示异步） 处理中-激活框从消息接收方的时间线上标记一小段时间，表示对消息进行处理的时间间隔。 在消息线末尾增加 + ，则消息接收者进入当前消息的“处理中”状态；在消息线末尾增加 - ，则消息接收者离开当前消息的“处理中”状态。 1234567sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 99 -&gt;&gt; seller: 还有炸鸡吗？ seller --&gt;&gt; 99: 没有，要现炸。 99 -x +seller:给我炸！ seller --&gt;&gt; -99: 您的炸鸡好了！ 1234567sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 99 -&gt;&gt; seller: 还有炸鸡吗？ seller --&gt;&gt; 99: 没有，要现炸。 99 -x +seller:给我炸！ seller --&gt;&gt; -99: 您的炸鸡好了！ 注解（note）语法如下 1Note 位置表述 参与者: 标注文字 其中位置表述可以为 表述 含义 right of 右侧 left of 左侧 over 在当中，可以横跨多个参与者 12345678910sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 Note over 99,seller : 热爱炸鸡 Note left of 99 : 女 Note right of seller : 男 99 -&gt;&gt; seller: 还有炸鸡吗？ seller --&gt;&gt; 99: 没有，要现炸。 99 -x +seller : 给我炸！ seller --&gt;&gt; -99: 您的炸鸡好了！ 12345678910sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 Note over 99,seller : 热爱炸鸡 Note left of 99 : 女 Note right of seller : 男 99 -&gt;&gt; seller: 还有炸鸡吗？ seller --&gt;&gt; 99: 没有，要现炸。 99 -x +seller : 给我炸！ seller --&gt;&gt; -99: 您的炸鸡好了！ 循环（loop）在条件满足时，重复发出消息序列。（相当于编程语言中的 while 语句。） 123456789101112sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 99 -&gt;&gt; seller: 还有炸鸡吗？ seller --&gt;&gt; 99: 没有，要现炸。 99 -&gt;&gt; +seller:给我炸！ loop 三分钟一次 99 -&gt;&gt; seller : 我的炸鸡好了吗？ seller --&gt;&gt; 99 : 正在炸 end seller --&gt;&gt; -99: 您的炸鸡好了！ 123456789101112sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 99 -&gt;&gt; seller: 还有炸鸡吗？ seller --&gt;&gt; 99: 没有，要现炸。 99 -&gt;&gt; +seller:给我炸！ loop 三分钟一次 99 -&gt;&gt; seller : 我的炸鸡好了吗？ seller --&gt;&gt; 99 : 正在炸 end seller --&gt;&gt; -99: 您的炸鸡好了！ 选择（alt）在多个条件中作出判断，每个条件将对应不同的消息序列。（相当于 if 及 else if 语句。） 123456789101112131415sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？ seller --&gt;&gt; 99 : 可卖的炸鸡数 alt 可卖的炸鸡数 &gt; 3 99 -&gt;&gt; seller : 买三只！ else 1 &lt; 可卖的炸鸡数 &lt; 3 99 -&gt;&gt; seller : 有多少买多少 else 可卖的炸鸡数 &lt; 1 99 -&gt;&gt; seller : 那我明天再来 end seller --&gt;&gt; 99 : 欢迎下次光临 123456789101112131415sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？ seller --&gt;&gt; 99 : 可卖的炸鸡数 alt 可卖的炸鸡数 &gt; 3 99 -&gt;&gt; seller : 买三只！ else 1 &lt; 可卖的炸鸡数 &lt; 3 99 -&gt;&gt; seller : 有多少买多少 else 可卖的炸鸡数 &lt; 1 99 -&gt;&gt; seller : 那我明天再来 end seller --&gt;&gt; 99 : 欢迎下次光临 可选（opt）在某条件满足时执行消息序列，否则不执行。相当于单个分支的 if 语句。 1234567sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 99 -&gt;&gt; seller : 买炸鸡 opt 全都卖完了 seller --&gt;&gt; 99 : 下次再来 end 1234567sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 99 -&gt;&gt; seller : 买炸鸡 opt 全都卖完了 seller --&gt;&gt; 99 : 下次再来 end 并行（Par）将消息序列分成多个片段，这些片段并行执行。 12345678910111213sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！ par 并行执行 seller -&gt;&gt; seller : 装可乐 and seller -&gt;&gt; seller : 炸炸鸡 end seller --&gt;&gt; 99 : 您的炸鸡好了！ 12345678910111213sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！ par 并行执行 seller -&gt;&gt; seller : 装可乐 and seller -&gt;&gt; seller : 炸炸鸡 end seller --&gt;&gt; 99 : 您的炸鸡好了！ 饼图（Pie）12345pie title Pie Chart \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 150 123456pie title Pie Chart &quot;Dogs&quot; : 386 &quot;Cats&quot; : 85 &quot;Rats&quot; : 150 &quot;panda&quot; : 200 Typora支持mermaid的官方链接 甘特图（gantt）12345678910 title 标题dateFormat 日期格式section 部分名任务名:参数一, 参数二, 参数三, 参数四，参数五 //参数一：crit（是否重要，红框框） 或者 不填 //参数二：done（已完成）、active（正在进行） 或者 不填(表示为待完成状态) //参数三：取小名 或者 不填 //参数四：任务开始时间 //参数五：任务结束时间 官方教程 123456789101112131415161718192021222324252627gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h 123456789101112131415161718192021222324252627gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h 基础篇视频讲解链接画图篇视频讲解链接","link":"/posts/2/"},{"title":"五官结构介绍","text":"嘴唇的形态结构唇部位于面部的下1/3处，指的是上下唇及口裂周围的面部组织，是面部活动范围最大的两个瓣状软组织结构。唇的上界为鼻底线，下界为颏唇沟，两侧以“八”字形唇面沟为界与颊部相邻。分为上唇和下唇两部分，两唇之间的横行裂称为口裂(俗称口)，口裂两端叫做口角。 嘴唇的组织构成上下唇均可以分成三部分：一是皮肤部(也叫白唇);二是红唇部，是口唇轻闭时，正面所见到的红色口唇部;三是粘膜部，在唇的里面，为口腔粘膜的一部分。 )) 上下唇的形态比较下唇的唇红缘呈不明显的”W”形，结构较上唇简单。红唇部较上唇稍厚，突度较上唇稍小，高度比上唇略短，与上唇对应协调。下唇与颏部的交界处形成一沟，名为颏唇沟，此沟存在与否及其深浅对容貌美有着直接影响。 生活中人们除了女孩涂口红或者男孩看美女之外，几乎很少注意到唇的存在，更不会关注嘴唇的细节，所以大都对嘴唇的认知甚少，以至于在电话里对医生描述你的唇部疾病的时候，大多数人都不知道怎样称呼唇的各个细节。 鼻子的结构与表现1、形体结构：鼻子在面部正中心位置。形状像楔子（梯形），从前额向下形状渐宽，体积渐大，由左、中、右、下四个基本面组成。分鼻根、鼻梁、鼻尖（头）、鼻翼四个部分组成。鼻根部与前额想接，鼻子上端由鼻骨（从鼻根部向下延伸至鼻子的一半）形成基本结构。鼻骨呈三角形，肌肉很薄，称为鼻梁。下半部则由软骨组成，分别称鼻尖（头）和鼻翼，共五块软骨。 耳部特征的表现规律和鼻子一样， 耳朵的年龄差异也不是非常明显。以此， 我们要把耳朵的形体特征作为绘画的重点。每个人耳朵的形状都是有差异的，表现时要把握它的基本结构特征才可掌握绘画要领。绘画时要从耳朵最为概括的大形着手， 层层深入地找出小形体才能找到每一处形体之间的来龙去脉。要体现耳朵与后脑的空间距离，以及它与头发的明暗对比和耳垂与颈部的空间距离。 耳部的角度特征1 ) 正面俯视角度耳部表现规律：俯视的耳朵整体高度变短。内外耳廓、耳窝等的顶面增大，底面消失或变小。整体透视有向下的趋势， 上宽下窄。 2 ) 正面仰视角度耳部表现规律：仰视的耳朵整体高度变短。外耳廓、耳窝等的顶面消失， 底面面积增大。整体透视有向上的趋势， 下宽上窄。 3 ) 半侧面角度耳部表现规律：半侧面耳朵的宽度最大。内外耳廓亮面变窄， 暗部变宽。三角窝及耳窝的立面增大， 面积增大。 4 ) 全侧面角度耳部表现规律：侧面的耳朵整体变的更窄， 呈长方形。三角窝及耳窝的立面进一步增大， 内外耳轮、耳垂、耳屏的侧面进一步减小， 注意内外耳轮前后空间关系产生的虚实变化。 眼睛结构和表现 虹膜（眼黑那个圆）的透视一定要画对 画聚焦时内外眼白的量也要画对，千万不能画成斜视（内眼白比外眼白量多） 顺便眼睛鼻子眉毛嘴巴的透视也要画对 以下来教学内容： 虹膜的圆的透视 红色为角膜 黄色为虹膜弧度 人体五官比例图解","link":"/posts/3c5449cf/"},{"title":"Hexo博客系统的搭建","text":"引言： Hexo可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。通过markdown编写文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器，或上传到Github、Gitee等仓库托管平台，在开启该类仓库的Pages服务后便可使用。简而言之：hexo是个静态页面生成、上传的工具。 Hexo简介Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub、Gitee或Coding上，是搭建博客的首选框架。 Hexo的搭建步骤 安装Git 安装Node.js(其中就包含了npm) 本地安装Hexo 验证是否能在本地浏览器访问Hexo博客系统 使用Github创建个人仓库 使用Gitee创建个人仓库 使用Coding创建个人仓库 生成SSH添加到Github,Gitee或Coding中 将本地的Hexo部署到以上创建的仓库中（可以同时上传到多个仓库中） 开启各个仓库的Pages服务（免费的） 访问个人博客（可以开始使用了） 本地写文章 同步上传到所需要部署的仓库中 一、安装GitGit官网地址 二、安装Node.jsnodejs官网地址 三、本地安装Hexo前面的Git和Nodejs安装好之后，就可以正式安装Hexo了。 建议在执行后续的安装命令时将npm的安装源更换成国内的镜像（淘宝的镜像），不然后续用到的npm安装命令都会很缓慢，而且可能还会在中途卡死，所以建议换源。使用以命令设置npm的镜像源：(也可以手动打开“C:\\Users\\Administrator”目录下的“.npmrc”文件，增加“registry=https://registry.npm.taobao.org” 即可，其中“Administrator”为你的用户名) 1npm config set registry https://registry.npm.taobao.org 使用如下命令查看npm是否换源成功： 1npm config get registry 若显示“https://registry.npm.taobao.org”，则说明换源成功！ npm换源成功后，使用如下命令安装Hexo到本地，别忘了“-g”这个参数： 1npm install -g hexo-cli 之后可以在任意文件目录中创建一个文件夹用来存放你的博客项目，比如名为 myblog,然后利用命令提示符的cd命令进入到该文件夹下，利用hexo来初始化你的博客系统： 1hexo init # 注意，该命令一定是要在你新建的那个文件夹目录下执行。 或者你也可以直接使用“hexo init myblog”命令，该命令会直接在当前目录下创建名为“myblog-hexo”的文件，并初始化项目。（其实hexo init命令本质上是利用Git从远端克隆项目到本地） 如果初始化过程中没有出现“error”（忽略WARN），那么初始化后，你的文件目录看起来应该是这样的：如果以上步骤一切正常，那么Hexo在本地的安装就成功了。 四、验证是否能在本地浏览器访问Hexo博客系统继续在以上该项目目录下，运行以下命令： 123hexo cleanhexo ghexo s hexo clean 命令用来删除之前生成的前端页面，即public文件夹，此时由于还没有任何前端界面，该目录下没有public文件夹。 hexo g 命令全称hexo generate，用来生成前端访问的界面，生成的文件会存放在“public”文件夹中 hexo s 命令全称hexo server 用来开启本地的Hexo服务，开启后可在本地通过浏览器访问生成的页面 运行以上三条命令后，可在本地打开浏览器，输入网址127.0.0.1:4000即可看到你生成的博客页面了，大概长这样：可以使用 Ctrl+c 把hexo服务关掉。至此，Hexo博客系统才算真正在本地安装成功了。 五、使用Github创建个人仓库到 Github官网 注册账号，并记住你的username和邮箱，username最好起得有个性，后面会用到。注册后应该是可以使用 “https://github.com/你的username” 访问到你的个人主页，该主页会显示出你的代码提交量情况和公开仓库等个人信息。比如我的username为yczlab,那么可以通过https://github.com/yczlab 访问到我的个人主页。注册并登录你的Github后，如下图，点击右上角 New repository，新建仓库：进行仓库创建时的设置：创建好该仓库后，进入该仓库,里面暂时只有一个README文件：点击该仓库右上角的Settings，找到Github Pages: 六、使用Gitee创建个人仓库到 Gitee官网 注册账号(Gitee是中国的类似于Github的代码托管平台，访问速度会比Github快很多，建议使用该平台来搭建Hexo)，并记住你的个人空间地址和邮箱，个人空间地址最好起得有个性，后面会用到，这里的个人空间地址并不是你的姓名。（个人空间可以在登录后，点击右上角头像选择“设置”，再选择“个人空间地址”查看并修改）注册后应该是可以使用 “https://gitee.com/你的个人地址空间” 访问到你的个人主页，该主页会显示出你的代码提交量情况和公开仓库等个人信息。比如我的个人地址空间为yczlab,那么可以通过https://gitee.com/yczlab 访问到我的个人主页。注册并登录你的Gitee后，如下图，点击右上角，新建仓库：进行仓库创建时的设置：同样创建好该仓库后，进入该仓库，里面暂时只README文件：点击该仓库右上角的“服务”，再点击“Gitee Pages”: 七、使用Coding创建个人仓库Coding的官网，在Coding中注册、登录、创建仓库，步骤与上面大同小异，这里就不在继续介绍了。本文主要介绍如何利用Hexo将博客系统同时部署到Github和Gitee中。 八、生成SSH公钥添加到Github,Gitee或Coding中以下方法为在Windows中生成并使用SSH工具 生成ssh公钥添加到Github保证 Git 已经正确安装好。进入“C:\\Users\\Administrator.ssh”目录下（其中Administrator为你的用户名），鼠标右键点击打开“Git Bash Here”，输入以下命令，并连续按三次回车键：1ssh-keygen -t rsa -C \"你的邮箱名称\" -f \"产生的公私钥名称\" 其中“你的邮箱”为你注册Github时使用的邮箱地址，比如QQ邮箱；“产生的公私钥名称”为你想要为其命名的名称，若不命名，则会使用默认的名称，会覆盖以前也使用默认名称的公私钥文件。比如我执行 ‘ssh-keygen -t rsa -C “2685733832@qq.com“ -f “github_rsa” ‘，结果如下：此时会在当前目录下生成两个文件“github_rsa”和“github_ras.pub”，一个为私钥（不要公开），另一个为私钥（可以公开）：用自己注册的账号登录Github官网，点击右上角的”Settings”——&gt;点击”SSH and GPG keys”——&gt;点击“New SSH key”，添加刚刚生成的公钥：现在还不能正常使用，因为在新生成这个公私钥文件的时候不是采用的默认命名，而是带了“-f”参数对该公私钥文件进行了重命名，所以本地的ssh服务可能就找不到我们新生成的公私钥文件，所以还需要在本地配置一下，才能正常使用。在该公私钥文件所在的目录下新建一个名为“config”的文件(注意该文件没有后缀)，往该文件中写入以下的信息，并保存： 12345# Github的公钥配置Host github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github_rsa #注意，最后这个地方换成你在生成该公私钥时的命名，比如我刚刚在生成时用的github_rsa，这里我就写成github_rsa 输入以下命令，验证是否可用： 1ssh -T -v git@github.com 显示以下信息，说明验证成功，可以使用：如果该过程没有成功，建议百度自行解决一下。至此，SSH公钥就成功添加到Github，并可以使用了。可以使用git命令对Github中的仓库进行克隆和上传代码。 生成ssh公钥添加到Gitee方法和上面的差不多，只是在生成的公私钥的时候注意命名不要和上面已有的公私钥名称重复了，邮箱（注册Gitee账号时用的邮箱）可以重复。比如：1ssh-keygen -t rsa -C \"2685733832@qq.com\" -f \"gitee_rsa\" 此时会在当前目录下生成两个文件“gitee_rsa”和“gitee_ras.pub”，一个为私钥（不要公开），另一个为私钥（可以公开）：用自己注册的账号登录Gitee官网，点击右上角的”头像”——&gt;点击”设置”——&gt;点击“SSH公钥”，添加刚刚生成的公钥：同样，现在还不能正常使用，还需要在本地配置一下，才能正常使用。在该公私钥文件所在的目录下新建一个名为“config”的文件(注意该文件没有后缀)，如果已有那就不用新建，往该文件中写入以下的信息，并保存： 12345# Gitee的公钥配置Host gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/gitee_rsa #注意，最后这个地方换成你在生成该公私钥时的命名，比如我刚刚在生成时用的gitee_rsa，这里我就写成gitee_rsa 输入以下命令，验证是否可用： 1ssh -T -v git@gitee.com 显示以下信息，说明验证成功，可以使用：如果该过程没有成功，建议百度自行解决一下。至此，SSH公钥就成功添加到Gitee，并可以使用了。可以使用git命令对Gitee中的仓库进行克隆和上传代码。 生成ssh公钥添加到Coding该过程基本和上面的步骤一样，如有需要，请参照上面的步骤自行添加ssh公钥到Coding中。 九、将本地的Hexo部署到以上创建的仓库中（可以同时上传到多个仓库中）在创建好Hexo想要部署到的平台的相应仓库后，便可以配置本地已安装好的Hexo博客系统，使本地的博客系统可以上传到相应的仓库，并供大家访问博客。 打开本地本地Hexo项目中的配置文件，即“_config.yml”文件，修改其中的以下内容，添加自己想要上传到的平台仓库中（这里我添加了两个,gitee和github）：然后打开命令提示符，利用cd命令进入该目录下，输入以下命令将本地项目上传到以上指定的仓库中： 12hexo g #生成静态页面至public目录hexo d #将.deploy_git目录部署到指定仓库地址 可能 “hexo d” 命令初次运行时会报错，那是因为该项目缺少”hexo-deployer-git”插件，在该项目中使用以下命令安装即可： 1npm install hexo-depoyer-git --save 然后再运行“hexo d”命令，该命令的执行速度可能有点慢，该命令本质是将本地的文件通过git上传到远端，可能中途还会失败。如果失败，就一直执行，直到成功即可。 十、开启各个仓库的Pages服务（免费的）关于各个仓库如何开启Pages服务，在上面创建仓库的步骤中就已说明，这里就不在重复。Github时默认开启Pages的，而Gitee在每次上传后都需要手动刷新。 十一、访问个人博客（可以开始使用了）成功上传后，就可以根据Pages服务中提供的地址访问你的博客了。比如我的地址：Gitee地址：https://yczlab.gitee.io/Github地址：https://yczlab.github.io/ 十二、本地写文章在本地的Hexo项目文件中利用一下命令生成一篇新的博客： 1hexo n \"博客名称\" 以上命令执行后便会在“source_posts\\”目录中生成一篇博客文章，可利用MarkDown语法来书写你的博客文章。 十三、同步上传到所需要部署的仓库中在你的文章写好后，执行以下命令同步上传到部署平台上： 12hexo ghexo d 注意：Gitee的Pages服务需要每次上传后手动刷新。","link":"/posts/d55a993f/"},{"title":"github page网站cdn优化加速","text":"CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科 放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。 图片加速关于图传以及GitHub作为图库的使用方法请参考文章：博客图片上传picgo工具github图传使用。 在上面参考文章的基础之上只需要修改以下配置：（指定相关cdn域名） 原来项目中使用了原来的方式，进行全局替换，Mac idea直接快捷键command+shift+R全局替换 【ps：题外话】原来是统一用的GitHub的仓库中的图片，通过这样替换，可以看到图片统一管理是多么的重要，多么的方便管理操作。 至此，博客中的相关图片都加上了cdn。 其余资源文件用法： 1https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 例如： 123https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.pnghttps://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.csshttps://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4 注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下： 123456789101112131415161718// 加载任何Github发布、提交或分支https://cdn.jsdelivr.net/gh/user/repo@version/file// 加载 jQuery v3.2.1https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js// 使用版本范围而不是特定版本https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.jshttps://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js// 完全省略该版本以获取最新版本https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js// 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js// 在末尾添加 / 以获取资源目录列表https://cdn.jsdelivr.net/gh/jquery/jquery/ 至此，github page 博客基本需要加速的完成。 参考文章:参考链接1参考链接2","link":"/posts/346ce02e/"},{"title":"博客换肤的一种实现方式思路","text":"当博客内容很多的时候，比如需要加载很多资源文件，许多炫酷的东西的时候，可能相应的就是比较慢了（正可谓时间和空间不能兼得）。虽然目前也有很多方式手段可以提高访问速度，但是博客提供一个简洁模式还是很有必要的，萝卜青菜，各有所爱嘛。说不定很多网友就当纯的想看看文字，不需要那些花里胡哨的东西。这时候提供个清爽模式就相当有用了。 正常模式和精简模式hexo框架2仓2主题，采用正常模式一个仓库，一个主题；精简模式另一个仓库，另一个主题。 本博客采用的github Page部署网站。大家都知道，一个github的账户名，只能够指定一个username.github.io的网址，所以两个仓库，两个主题的话，就必须有一个挂在username.github.io之上，比如正常模式username.github.io，精简模式为username.github.io/name.io。 正常模式正常模式里面可以放各种炫酷的东西，提供丰富的页面。 精简模式只提供必要的文章，归档，分类，搜索基本的东西就够了。看个人需要，既然要简洁，就尽量的少弄一些。 配置方法关于_config.yml主配置文件的注意事项。 1234567891011+ root: /remove.io/ #精简模式- root: / #正常模式deploy: type: git+ repo: https://github.com/removeif/remove.io.git #精简模式- repo: https://github.com/removeif/removeif.github.io.git #正常模式+ theme: icarus #正常模式- theme: nextn #精简模式 对于root 根节点的说明，因为精简模式的所有资源文件都是挂在 username.github.io/remove.io/ 所以相当于根节点为/remove.io/ 总结注意事项 对于页面中对于对应模式下资源文件的引用，一定加上域名地址 ，比如原来图片访问/image/tuizi.jpg，在精简模式的时候如果继续这样用，就找不到，对应模式下的图片了，需要加上前面的username.github.io/remove.io/ 地址。 对于精简模式下，能去掉的东西就尽量去掉，尽量少加载一些，速度更快。 对于冲突页面的处理，一般对于文章或者关于页面都是通用。文章一般没啥影响，但是关于页面，可能有些也有很炫酷的模块。对于精简模式，可能不需要，此时就需要多new 一个page页面，分开配置，比如下面主题中的_config.yml配置。 12+ /remove.io/abouta/ #精简模式- /abouta/ #正常模式 本博客正常模式 精简模式 以上只是提供了一种解决方法思路，肯定还有更好的方式。","link":"/posts/1c5449cf/"},{"title":"安装、部分配置icarus主题中文版","text":"摘要发现icarus主题还不错，花了一两个小时研究了下安装、部分配置icarus主题中文版 安装icarus 直接下载主题模块放到blog项目 ,blog项目根目录执行 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 此时已经下载到项目中。 顶级_config.yml中选择icarus主题 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus 此时主题已经安装好，清除、编译、部署可以看到效果了 配置icarus 完全参照官网配置，进行翻译解说 配置文章部分顶部图片添加icarus 主题中的配置_config.yml中开启图片开关 12article: thumbnail: true 文章.md文件头中添加图片绝对/相对地址 12345title: Getting Started with Icarusthumbnail: /gallery/thumbnails/desert.jpg// thumbnail:https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620152744.png---Post content... 配置完成后部署显示效果如下(最新文章列表显示缩略图、文章开头显示一张设置图片) 左边文章导航栏开启icarus 主题中的配置_config.yml中开关 1234widgets: - type: toc position: left 同事文章顶部加入标签 1234title: Table of Contents Exampletoc: true---Post content... 配置效果 评论系统开启icarus 主题中的配置_config.yml中开启（部分评论系统需要翻墙才能使用，valine不用翻墙个人推荐，valine安装参考） 1234567comment: type: valine app_id: xxxxxxxx # (required) LeanCloud application id app_key: xxxxxxxx # (required) LeanCloud application key notify: false # (optional) receive email notification verify: false # (optional) show verification code placeholder: xxxxxxxx # (optional) comment box placeholder text 开启效果 捐赠收款开启icarus 主题中的配置_config.yml中开启 注意如果默认不配置，编译时有报错，可以# 把它注释掉，不启用功能 1234567891011donate: - # Donation entry name type: alipay # Qrcode image URL qrcode: 'https://wx2.sinaimg.cn/large/b5d1b710gy1g0lvxdcwm0j20p011i4bg.jpg' - # Donation entry name type: wechat # Qrcode image URL qrcode: 'https://wx2.sinaimg.cn/large/b5d1b710gy1g0lvwdcpb5j20u014qgy2.jpg' 开启配置效果如下 全局搜索开启icarus 主题中的配置_config.yml中开启,不同的搜索类型需要安装插件参考官网,type: insight此类型不需要安装，已经内置 12search: type: insight 效果如下 更多配置请参考官网配置目前配置基本已经够使用，还需要更多配置请参考连接 参考自","link":"/posts/52c38f29/"}],"tags":[{"name":"EnvConfig","slug":"EnvConfig","link":"/tags/EnvConfig/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"cg教程","slug":"cg教程","link":"/tags/cg%E6%95%99%E7%A8%8B/"},{"name":"工具教程","slug":"工具教程","link":"/tags/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"},{"name":"icarus主题配置","slug":"icarus主题配置","link":"/tags/icarus%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"name":"hexo主题","slug":"hexo主题","link":"/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"Diary","slug":"Diary","link":"/tags/Diary/"},{"name":"人体结构学习笔记","slug":"人体结构学习笔记","link":"/tags/%E4%BA%BA%E4%BD%93%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Normalmap","slug":"Normalmap","link":"/tags/Normalmap/"}],"categories":[{"name":"EnvConfig","slug":"EnvConfig","link":"/categories/EnvConfig/"},{"name":"cg教程","slug":"cg教程","link":"/categories/cg%E6%95%99%E7%A8%8B/"},{"name":"工具教程","slug":"工具教程","link":"/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"},{"name":"人体结构","slug":"cg教程/人体结构","link":"/categories/cg%E6%95%99%E7%A8%8B/%E4%BA%BA%E4%BD%93%E7%BB%93%E6%9E%84/"},{"name":"主题工具","slug":"工具教程/主题工具","link":"/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E4%B8%BB%E9%A2%98%E5%B7%A5%E5%85%B7/"},{"name":"Diary","slug":"Diary","link":"/categories/Diary/"},{"name":"uncategorized","slug":"uncategorized","link":"/categories/uncategorized/"},{"name":"人体结构学习笔记","slug":"人体结构学习笔记","link":"/categories/%E4%BA%BA%E4%BD%93%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Normalmap","slug":"Normalmap","link":"/categories/Normalmap/"}]}